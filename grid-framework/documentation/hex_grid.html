<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Grid Framework: Hexagonal grids</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Grid Framework
   &#160;<span id="projectnumber">1.8.3</span>
   </div>
   <div id="projectbrief">Easy grid setup and scripting for Unity 3D</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('hex_grid.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Hexagonal grids </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>The <a class="el" href="class_g_f_hex_grid.html" title="A grid consisting of flat hexagonal grids stacked on top of each other. ">GFHexGrid</a> class </h2>
<p>Hex grids resemble honeycomb patterns, they are composed of regular hexagons arranged in such a way that each hex shares an edge with another hex. The distance between two neighbouring hexes is always the same, unlike rectangular grids where two rectangles can be diagonal to each other.</p>
<div class="image">
<img src="hex_inspector.png" alt="hex_inspector.png"/>
</div>
<p>The size of a hex is determined by the grid’s <code>radius</code>, the distance between the centre of a hex and one of its vertices. A honeycomb pattern is two-dimensional and the grid’s <code>gridPlane</code> determines whether it’s an XY-, XZ- or YZ grid. These honeycomb patterns are then stacked on top each other, the distance between two of them being defined by the grid’s <code>depth</code>, to form a 3D grid.</p>
<div class="image">
<img src="hex_geometry.png" alt="hex_geometry.png"/>
</div>
<p>The angle between two vertices is always 60° or 2/3π. The distance between opposite vertices is twice the radius. The distance between adjacent hexes is the same as the distance between adjacent edges, <code>sqrt(3)*radius</code>.</p>
<h2>Different kinds of hex grids </h2>
<p>There are several ways to define a hex grid. For one, you can have hexes with pointy sides (default) or with flat sides. As mentioned above, you have three different grid planes. For the sake of simplicity I’ll be using the terms for XY-grids from now on. If you have another grid plane replace X, Y and Z with the respective coordinate, meaning for a top-down XZ grid X would refer to the local “X”- axis, “Y” to the local Z-axis and “Z” to the local Y-axis.</p>
<div class="image">
<img src="hex_grids.png" alt="hex_grids.png"/>
</div>
<p>There are multiple ways of drawing a hex grid as well: currently the supported patterns are rectangle, rhombus and herringbone, all in up-and downwards variants plus a compact one for the rectangle.</p>
<h3>Circles and triangles</h3>
<p>One particular drawing shape is the <em>circle</em>, a series of hexagons looping around a central hexagon. This shape is similar to the shape of a polar grid, except for hex grids. The X-coordinate gives us the radius of the circle and the Y-coordinate the angle. The radius and layer distance are either relative or absulute to the radius and depth of the grids, depending on you settings, but the angle is always in hexes. The shape is drawn around a central position which is given in grid coordinates as <code>renderAround</code>. Unlike the <em>origin offset</em> this does not move the coordinate system of the grid, only the visible representation.</p>
<div class="image">
<img src="hex_circle.png" alt="hex_circle.png"/>
</div>
<p>It is possible to draw only part of the shape, thus creating a sort of cone or triangle. This shape is different from the other ones in that is cannot be boxed into a rectangular shape, so the rendering range has to be interpreted in a different way:</p>
<ul>
<li>The radius cannot go below 0, if it does it is automatically treated as 0.</li>
<li>If the end angle is more than six units larger than the start angle the shape will wrap around.</li>
<li>A negative start angle can wrap the shape around if it is five or more units less than the end angle.</li>
<li>Relative and absolute size is ignored for the angle.</li>
</ul>
<p>All of these would not make any sense for a circular shape anyway and the polar grids prevents these settings from happening in the first place. However, since they would make sense for the other hex shapes I decided not to hijack the user's settings.</p>
<h2>Coordinate systems in hex grids </h2>
<p>In rectangular grids we place the grid along the vertices, but for hex grids it’s more intuitive to use the faces instead with the central face of the central hex as the origin.</p>
<p>Currently there are four coordinate systems available (plus world coordinates of course): cubic, rhombic, upwards herringbone and downwards herringbone. I will explain the various coordinate systems and their respective advantages and disadvantages in detail below.</p>
<h3>Converting between coordinate systems</h3>
<p>At any time you can convert between any of the coordinate systems (including world). The method to call follows the following convention: <code>OriginalToTarget(point)</code> where <em>Original</em> and <em>Target</em> are either <code>World</code>, <code>Cubic</code>, <code>Rhombic</code>, <code>HerringU</code> or <code>HerringD</code> and <em>point</em> is either a Vector3 (world, rhombic or herringbone) or a Vector4 (cubic). There is also the coordinate system <code>Grid</code>, it is equivalent to <code>HerringU</code>.</p>
<h3>Cubic coordinates</h3>
<p>In old games, like Qbert, the game world would appear to be in 3D with cubes, but it was actually in 2D and the cubes were actually hexagons; you could use a three dimensional coordinate system in the game and then embed it into the two dimensional plane. The cubic coordinate system follows the same idea.</p>
<div class="image">
<img src="hex_cubic.png" alt="hex_cubic.png"/>
</div>
<p>There are three axes, called <em>X</em>, <em>Y</em> and <em>Z</em>. At any given point their sum is always 0. This is because in a Qbert game every time we move in one of the three directions we also move away from another. Or in other words, the axes span a plane going diagonally through space, resulting in the condition.</p>
<p>On top of that there is a fourth <em>W</em> coordinate. The first three coordinates tell us the position on the plane and the fourth coordinate tells us the distance from the central plane. It is given as a multiple of <code>depth</code>.</p>
<p>This coordinate system is very nice to use, because its three-dimension nature fits well with the six-sided hexagons, just as the two-dimensional cartesian coordinate systems fits four-sided squares. Many algorithms are very easy to write this way, and that is the the reason why it is used internally in Grid Framework and all other coordinate expressions are conversions. The downside is that it can be rather awkward to understand if you are just looking for a simple coordinate system.</p>
<h3>Rhombic coordinates</h3>
<p>Rhombic coordinates are a simplification of cubic coordinates. Instead of three axes we use only two, like in a cartesian coordinates system, but the angle between axes is 60° instead of 90°. If the hexes have pointy sides moving up moves you north and moving right moves you north-east. If the hexes have flat sides moving up moves you north-east and moving right moves you east.</p>
<div class="image">
<img src="hex_rhombic.png" alt="hex_rhombic.png"/>
</div>
<p>The third coordinate, <em>Z</em>, is again the distance from the central plane as a multiple of <code>depth</code>. This coordinate system is fairly intuitive and a good choice for most tasks.</p>
<h3>Herringbone coordinates</h3>
<p>The herringbone pattern ows its name to the fact that it resembles the skeleton of a fish. One axis (Y for pointy sides and X for flat sides) is the regular cartesian axis, while the other axis zig-zags up and down (pointy sides) or left and right (flat sides).</p>
<div class="image">
<img src="hex_herring.png" alt="hex_herring.png"/>
</div>
<p>Whether the zig-zagging axis is moving up (right for flat sides) or down (left for flat sides) depends on whether the left column (lower row for flat sides) is even or odd. In upwards coordinates the odd columns are shifted upwards (left) relative to the even ones, while in the downwards coordinate system they are shifted downwards (right).</p>
<p>While this coordinate system is <em>very</em> intuitive it raises an important issue: where exactly on the grid a pair of coordinates points to depends on whether it is even or odd. Let's say we have our player at (0,0) in a pointy side grid and want to move north-east. Then we add (1,0) to player's position. However, if we want to move north-east again now we have to add (1,1) to the new position, because we are now in an odd column and the X-axis goes downwards. Adding (0,1) would move south-east.</p>
<p>If you want to use herringbone coordinates you will always have to make a distinction between even and odd cases. That's why I wouldn't recommend using this coordinate system for game mechanics such as movement. On the other hand, its rectangular structure makes it a good choice for building level maps.</p>
<h2>Nearest vertices, faces and boxes </h2>
<p>The methods for finding the nearest <em>something</em> adhere to the following convention: <em>NearestSomethingX (point)</em> where <em>point</em> is a point in world space, <em>something</em> is either <code>Vertex</code>, <code>Face</code> or <code>Box</code> and <em>X</em> is either <code>W</code> (world), <code>C</code> (cubic), <code>R</code> (rhombic), <code>HU</code> (upwards herringbone), <code>HD</code> (downwards herringbone) or <code>G</code> (grid, equivalent to <code>HU</code>). In rectangular grids we need to specify a <em>plane</em> for faces, here the plane of the grid is used. You can omit that parameter and even if you specify one it will be ignored.</p>
<h2>The plane of hex grids </h2>
<p>As mentioned in the sections <em>The GFGridPlane</em>, <em>The <a class="el" href="class_g_f_layered_grid.html" title="The parent class for all layered grids.">GFLayeredGrid</a> class</em> and <em>Different kinds of hex grids</em>, hex grids can be oriented to different planes. When you are making a top-down game your will most likely be working on an XZ-grid and your object will move in X- and Y directions. Consequently your entire game logic will be about the X- and Z coordinate of their position.</p>
<p>Therefore it makes sense that grid coordinates follow this pattern as well. The X-, Y- and Z components of rhombic and herringbone coordinates will be mapped to their respective counterparts, i.e. in an XZ-grid the X coordinate stays X, the Y coordinates becomes Z and the Z coordinate becomes Y. Cubic (and later barycentric) coordinates are not affected by this, they already have more dimensions than the surrounding space, so it makes no sense to transform the embedding mapping.</p>
<h2>Aligning and scaling to hex grids </h2>
<p>In the case of rectangular grids objects get aligned either on or between faces depending on whether their scale is an even or odd multiple of the spacing. In hex grids this distinction makes no sense, it's like trying to fit a square peg into a round hole, so instead the object's pivot point will be aligned with the center of the nearest hex. I also looked at other hex-based games and how they handled it and they used the same pivot point approach.</p>
<p>Usually and object's pivot point is its centre, you can either change it in your 3D modeling application or make the object a child of an empty object and use that parent as the pivot point. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.3.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Nov 17 2015 18:35:35 for Grid Framework by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>
