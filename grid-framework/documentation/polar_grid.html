<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Grid Framework: Polar grids</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Grid Framework
   &#160;<span id="projectnumber">1.8.3</span>
   </div>
   <div id="projectbrief">Easy grid setup and scripting for Unity 3D</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('polar_grid.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Polar grids </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>The <a class="el" href="class_g_f_polar_grid.html" title="A polar grid based on cylindrical coordinates.">GFPolarGrid</a> class </h2>
<p>In this section I will refer to the grids a <em>polar</em> for the sake of simplicity, even though they are technically <em>cylindrical</em>. Any cylindrical coordinate system can be regarded as polar simply by omitting the third coordinate.</p>
<p>The defining characteristics of polar grids are <code>radius</code>, <code>sectors</code> and <code>depth</code>. There are two coordinate systems, a standard cylindrical one and a grid coordinate system similar to what the other grids use.</p>
<div class="image">
<img src="polar_inspector.png" alt="polar_inspector.png"/>
</div>
<p>The <code>radius</code> is the radius of the innermost circle around the origin and the radii of all the other circles are multiples of it. The next value, <code>sectors</code>, tells us into how many sectors we divide the circles. It’s an integer value of at least one (the circle itself is one huge sector). We derive the angle between sectors by dividing 2π (or 360°) by the amount of sectors. We cannot set the angle directly, because the sum of all angles has to form a full circle, thus only certain values are possible. Finally, <code>depth</code> gives us how far apart two grid planes are. If you want to use pure polar coordinates you can ignore this value, but it is relevant if you want to use cylindrical coordinates (i.e. 3D).</p>
<p>Coordinates are processes as Vector3 values. From now on I will only be explaining coordinates in a XY-grid, for other grids the roles of the X-, Y- and Z-component are different to reflect the way cartesian coordinates would be handled. Please refer to the following table to see how to interpret the values.</p>
<table class="doxtable">
<tr>
<th></th><th>XY-grid </th><th>XZ-grid </th><th>YZ-grid  </th></tr>
<tr>
<td>X-component </td><td>radius </td><td>height </td><td>radius </td></tr>
<tr>
<td>Y-component </td><td>polar angle </td><td>polar angle </td><td>height </td></tr>
<tr>
<td>Z-component </td><td>height </td><td>radius </td><td>polar angle </td></tr>
</table>
<h2>What are polar and cylindrical coordinates? </h2>
<p>Polar grids are based on polar coordinates. In the usual cartesian coordinate system we identify a given point through its distance from the origin by looking at its distance from the coordinate axes (or if you prefer linear algebra, as the linear combination of the coordinate system’s basis vectors).</p>
<p>In a <a href="http://en.wikipedia.org/wiki/Polar_coordinate_system">polar coordinate</a> system we identify a point by its absolute distance (radius or radial coordinate) from the origin (pole) and its angle (angular coordinate, polar angle or azimuth) around a given axis (polar axis).</p>
<p><a href="http://en.wikipedia.org/wiki/Cylindrical_coordinate_system">Cylindrical coordinates</a> are polar coordinates with a third axis added for the distance (height or altitude) from the reference plane (the plane containing the origin). We call this third axis the cylindrical or longitudinal axis.</p>
<h2>Degree VS radians </h2>
<p>There are two common ways to measure angles: as degrees, ranging from 0° to 360° and as <a href="http://en.wikipedia.org/wiki/Radians">radians</a> ranging from 0 to 2π. Since radians is the preferred method in mathematics and other branches of science Grid Framework is using radians internally for all angles. Some values can be read or written in degrees as well, but the result is always internally stored as radians. Keep in mind that you can convert between degree and radians using Unity’s own <a href="http://docs.unity3d.com/Documentation/ScriptReference/Mathf.html">`Mathf`</a> class.</p>
<h2>Float VS angle </h2>
<p>No matter whether you are using radians of degree, an angle is always saved as a float type value, either on its own or as part of a vector. Since float numbers can be negative or exceed the range of radians (2π) and degree (360°) there need to be some restrictions in place.</p>
<p>If the number is larger than the range it gets wrapped around, meaning 750° becomes 30° (since 750 = 2 * 360 + 30). If the number is negative it gets subtracted from a full circle (after being wrapped around). In the case of -750° we would get 330° (since 330 = 360 - 30 and 750 = 2 * 360 + 30).</p>
<p>These restrictions are always applied internally when you are using a polar grid’s methods and accessors, so you won’t have to worry about anything. Just be aware of what’s happening in case your circles start going the other way around or something like that.</p>
<h2>The polar coordinate system </h2>
<p>This is a standard cylindrical coordinate system and internally it is the default coordinate system. In a standard XY-grid the first coordinate is the <em>radius</em>, the second coordinate is the <em>polar angle</em> and the third coordinate is the <em>height</em>, all distances measured in world length. This coordinate system is not affected by <code>radius</code>, <code>sectors</code> or <code>depth</code>, it’s great if you want to have full control over your points. For general information about polar and cylindrical grids please refer to a mathematical textbook (or Wikipedia ^^).</p>
<h2>The grid coordinate system </h2>
<p>This one is similar to the above, except the values now are directly influenced by <code>radius</code>, <code>sectors</code> and <code>depth</code>. The <em>radius</em> gives us the distance from the origin as a multiple of the grid’s <code>radius</code> and the <em>height</em> is a multiple of the grid’s <code>depth</code>. The curious value is the <em>angle</em>, because rather than being the angle in radians or degrees it tells us how many sectors we are away from the polar axis. The maximum number is the amount of segments.</p>
<p>This coordinate system is great if you want to think in terms of “grid points”, for example in a board game. If you want to move the player one unit towards the outside and two units counter-clockwise you could write </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;var myPlayerPosition: Vector3 = myGrid.WorldToGrid(player.transform.position);</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;myPlayerPosition += Vector3(1, 2, 0);</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;player.transform.position = myGrid.GridToWorld(myPlayerPosition);</div>
</div><!-- fragment --><p> Note how you don’t need to know anything about the grid and its values, you just concentrate on the movement itself.</p>
<div class="image">
<img src="polar_grid.png" alt="polar_grid.png"/>
</div>
<h2>Displaying the grid </h2>
<p>Polar grids contain circles, but the computer cannot draw circles, it can only draw straight lines. Since a polar grid where only straight lines connect the sectors would look bad we have a <code>smoothness</code> value. What smoothing does is it adds extra “sectors” between the sectors to break the lines int shorter segments, creating a rounder look. Keep in mind that this does affect performance, so you have to find a good balance between look and performance. Usually a single digit number is already good enough and the more sectors you have, the less smoothing you need.</p>
<div class="image">
<img src="polar_smooth.png" alt="polar_smooth.png"/>
</div>
<p>When using the <code>size</code> of a grid the values represent how large the grid is, how far the angle goes and how many layers to display. The first and third value cannot get lower than 0 and the second values is bounded between 0 and 2π (360°). If you decide to use a custom range the angle of the from-value can be larger than the to-value without problems. The angle values loop around as described in <em>Float VS angle</em>.</p>
<h2>Aligning and scaling </h2>
<p>When aligning a transform only its Z-scale is taken in account, just as with rectangular grids, but the X- and Y value is ignored, because it makes no sense to force something straight into a circle. Instead they will snap both on and in between circle segments and radial lines, depending on which is closer. The same rule applies to scaling as well. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.3.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Nov 17 2015 18:35:35 for Grid Framework by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>
