<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8"                                              />
		<meta name="author"       content="HiPhish"                        />
		<meta name="description"  content="Website for HiPhish's projects."/>
		<meta name="keywords"     content="Grid, Framework, Unity, Asset"  />

		<link href="../main.css"       rel="stylesheet"  media="all"  type="text/css">
		<link href="../headerbar.css"  rel="stylesheet"  media="all"  type="text/css">
		<link href="../toolbar.css"    rel="stylesheet"  media="all"  type="text/css">

		<title>Grid Framework - Features</title>

		<!-- SyntaxHighligher -->
		<script type="text/javascript" src="../syntaxhighlighter_3.0.83/scripts/shCore.js"       ></script>
		<script type="text/javascript" src="../syntaxhighlighter_3.0.83/scripts/shBrushCSharp.js"></script>
		<script type="text/javascript">SyntaxHighlighter.all();</script>
		<link type="text/css" rel="stylesheet" href="../syntaxhighlighter_3.0.83/styles/shCoreDefault.css" />
		<link type="text/css" rel="stylesheet" href="../syntaxhighlighter_3.0.83/styles/shThemeDefault.css"/>
		<!-- SyntaxHighligher -->
	</head>
	<body id="grid-fwk">
		<nav id="headerbar">
			<ul>
				<li class="home"    ><a href="../"                                  > Home           </a> </li>
				<li class="grid-fwk"><a href="."                                    > Grid Framework </a> </li>
				<li class="blog"    ><a href="http://unitygridframework.blogspot.de"> Blog           </a> </li>
				<li class="about"   ><a href="../about"                             > About          </a> </li>
			</ul>
		</nav>
	
		<nav id="toolbar">
			<ul>
				<li class="button"><a href="https://www.assetstore.unity3d.com/#/content/4004"                   > Buy Now                </a></li>
				<li><a href="http://forum.unity3d.com/threads/144886-Grid-Framework-scripting-and-editor-plugins"> Support (Unity forums) </a></li>
				<li><a href="screenshots"                                                                        > screenshots            </a></li>
				<li><a href="examples"                                                                           > Examples               </a></li>
				<li><a href="features"                                                                           > Features               </a></li>
				<li><a href="."                                                                                  > Overview               </a></li>
			</ul>
		</nav>
	
		<div id="maincontent" >
			<h1>How it works</h1>
			<p>
				The heart of Grid Framework are the new grid classes. They are
				components, so you add them to any of your Game Objects you
				whish.  You can add grids either using the editor or
				programatically at runtime and modify its properties:
			</p>
		
			<script type="syntaxhighlighter" class="brush:csharp"><![CDATA[
				GameObject go;
				GFRectGrid grid = go.AddComponent<GFRectGrid>();
				// Set up the grid for 2:1 dimetric graphics
				grid.spacing  = new Vector3(2, 1, 1);
				grid.shearing = new Vector6(-1/2, 0, 2, 0, 0, 0);
				// Vector6 is a custom type, not part of the Unity API
			]]></script>
		
			<p>
				The grid classes are prefixed with "GF" to prevent name
				collisions with other types you might have in your own code.
				Ideally they would be properly namespaced, but the Unity editor
				has problems with namespaced components. Other custom types,
				such as Vector6 on the other hand are namespaced and will not
				collide with other types.
			</p>
		
			<p>
				All grids are in a class hierachy that allows you write common
				code once and have if work for all kinds of grids:
			</p>
		
			<script type="syntaxhighlighter" class="brush:csharp"><![CDATA[
				// This will work for any grid
				GFGrid  grid;
				Vector3 gridCoordinates = grid.WorldToGrid(worldCoordinates);
				// The exact implementation depends on the type of grid
			]]></script>
		
			<p>With the grid set up in your scene you are ready to go. You now have
			access to a vast and rich API you can use for your own application.</p>
			
			<h1>calculations</h1>
			
			<p>
				Grid Framework can convert from world coordinates to grid coordinates
				and vice- versa with just one line of code. You can let it find the
				nearest vertex, face or box, scale objects or snap them in place
				without needing to write any formulae, it's all wrapped up for you.
				This allows you to write your game logic thinking entirely in grid
				coordinates while the game plays out in world coordinates. Then just
				let Grid Framework convert the result back into world space and you're
				ready to go.
			</p>
		
			<p>
				Let's say we wanted to move a unit from one point in the grid
				to another. If we know the grid coordinates we can compute the
				world coordinates and pass them to your movement function:
			</p>
		
			<script type="syntaxhighlighter" class="brush:csharp"><![CDATA[
				Vector3 origin      = grid.gridToWorld(originInGrid   );
				Vector3 destination = grid.gridToWorld(desinatioInGrid);
				MoveUnit(from: origin, to: destination);
			]]></script>
		
			<p>
				A common task is snapping things to a grid, for example when
				the player is trying to place building in a strategy game. This
				is where the SnapToGrid method comes into play:
			</p>
		
			<script type="syntaxhighlighter" class="brush:csharp"><![CDATA[
				Transform object;
				// Move the object the usual way with no snapping first
				// And then correct its position by snapping
				grid.AlignTransform(object);
			]]></script>
		
			<p>
				Usually the AlignTransform method is smart enough to do what
				you want, but if you want more control you can use the
				lower-level methods to build your own rules.
			</p>
			
			<h1>infinite size and fully 3D</h1>
			
			<p>
				The size of a grid is irrelevant, what really defines a grid is its
				origin, its type and a few parameters. Using this information we can
				perform any calculation at any point, no matter how far from the origin
				we are. In fact, the distance doesn't even impact our performance, all
				calculations always run at the same speed. Of course Grid Framework's
				infinity is limited to what Unity is capable of and there is no true
				infinity on computers, but Grid Framwork can get as close to it as
				possible in Unity.  Best of all, grids are in 3D and move and, being
				components, rotate with the object they are attached to; if you need a
				grid's rotation or position just get the information from the Transform
				component, like any other object in Unity.
			</p>
		
			<script type="syntaxhighlighter" class="brush:csharp"><![CDATA[
				// This works as you would expect
				Quaternion gridRotation = grid.transform.rotation;
			]]></script>
		
			<h1>Extremely lightweight</h1>
			
			<p>
				Grid Framework was designed to keep it simple, to just be there when
				you need it but never intrude with the workflow. All calculation
				methods run in constant time and the classes just store a handful of
				float values, keeping the performance impact to a minimum. Regardless
				of whether you are targeting desktop devices or mobile phones and
				tablets, Grid Framework will work with a minimum of resources.
			</p>
		
			<h1>rendering &amp; drawing</h1>
			
			<p>
				You can both draw your grids in the editor using gizmos and render them
				at runtime. You can turn individual axes on or off, set the colour for
				each axis individually, change the width of the lines and even use your
				own shaders if the default shader doesn't suit your needs. Redering is
				done using Unity's low-level rendering capabilities, so it is blazing
				fast even on mobile devices. Keep in mind though, that while the
				rendering is cheap, getting points for large and very dense grids might
				not be. If your grids are exceptionally large you will be glad to know
				that Grid Framework can compute points for use witht the popular
				Vectrosity add-on.
			</p>
		
			<script type="syntaxhighlighter" class="brush:csharp"><![CDATA[
				// Set the rendering range and colour, turn off the Z-axis
				grid.renderFrom = new Vector3( 0,  0, 0);
				grid.renderTo   = new Vector3(10, 10, 5);
				grid.axisColors = new ColorVector3(Color.black);
				grid.hideAxis.z = true;
			]]></script>
			
			<h1>Vectrosity support</h1>
			
			<p>
				Vectrosity is a popular 3rd party vector line drawing solution for
				Unity. Instead of rendering lines point by point, Vectrosity can
				construct a mesh and then render the mesh in one go, making it an ideal
				solution for complex shapes with many points, such as very dense grids.
				Using Vectrosity on its own would require you to compute all end points
				yourself and then order them in the proper way so they appear in the
				right order; Grid Framework can do the job for you by just calling the
				built in method. For more information on Vectrosity please visit <a
				href="http://starscenesoftware.com/vectrosity.html"> Vectrosity's web
				site</a>. Vectrosity and Grid Framework are entirely unrelated products and
				I am in no way affiliated with the author of Vectrosity.
			</p>
		
			<script type="syntaxhighlighter" class="brush:csharp"><![CDATA[
				// Grid Framework gets the points and then Vectrosity takes over
				gridLine = new Vectrosity.VectorLine("My lines", grid.GetVectrosityPoints(), lineColors, lineMaterial, lineWidth);
			]]></script>
		
			<p>
				Plese keep in mind that Vectrosity and Grid Framework are
				entirely unrelated products and I am in no way affiliated with
				the author of Vectrosity.
			</p>
		
			<h1>Playmaker support</h1>
			
			<p>
				Grid Framwork also supports the popular
				<a href="http://hutonggames.com">Playmaker</a>
				add-on for visual scripting. The entire API, except for a few
				instances, is available as Playmaker actions. You can use
				these action as building blocks in your state machines to
				get and set properties and call methods.  Due to technical
				reasons any properties that rely on types not built into
				Unity cannot be set or gotten; they will be added if
				Playmaker becomes capable of handling custom types.
			</p>
			
			<h1>fits seamlessly into Unity</h1>
			
			<p>
				There is no new interface to learn or new editor panel to add to the
				project (unless you want to use the align panel of course), instead it
				fits nicely into Unity as if it had always been a part of it. The grid
				classes have their own custom inspector and you can create grids from
				scratch, add a grid component to any of your Game Objects or browse the
				documentation right from you menu bar, just like any other component in
				Unity.
			</p>
			
			<h1>full documentation</h1>
			
			<p>
				Like Unity itself, Grid Frameworks comes with a user manual that
				explains you the ideas and concepts of Grid Framework, the coordinate
				sytems used and the design principles. The scripting reference has all
				classes with their member variables and methods covered. Hyperlinks to
				entries in the documentation as well as links to Unity's own scriptiong
				reference let you find anything conventiently.
			</p>
			
			<h1>free updates</h1>
			
			<p>
				As Grid Framework improves update will be released adding new features.
				Once you buy a copy of Grid Framework you will be entitled to all
				future updates for free, even if the price goes up.  This is my way way
				of thanking everyone who supports me in the early stages :)
			</p>
		</div>
	</body>
</html>
