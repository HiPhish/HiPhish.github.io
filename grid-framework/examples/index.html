<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<title>Examples - Grid Framework</title>

		<!-- HTML page metadata -->
		<meta charset="utf-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<meta http-equiv="Content-type" content="text/html; charset=utf-8" />
		<meta name="description" content="HiPhish's Workshop" />
		<meta name="author" content="HiPhish" />

		<!-- Favicon if one is set -->


		<!-- Style sheets -->

		<!-- Bootstrap integration -->
		<link rel="stylesheet" href="http://hiphish.github.io/css/bootstrap.min.css" />



		<!-- Main theme CSS file taking precedence over Bootstrap -->
		<link rel="stylesheet" href="http://hiphish.github.io/theme/css/main.css" />


		<!-- Code highlight using CSS classes from Pygments -->
		<link rel="stylesheet" href="http://hiphish.github.io/theme/css/pygment.css" />

		<!-- "Holy Grail" page design -->
		<link rel="stylesheet" href="http://hiphish.github.io/theme/css/grail.css" />

		<!-- Collapsible tree-like Bootstrap list groups -->
		<link rel="stylesheet" href="http://hiphish.github.io/theme/css/list-tree.css" />

		<script src="http://hiphish.github.io/js/jquery.min.js"></script>
		<script src="http://hiphish.github.io/theme/js/main.js"></script>

		<script src="http://hiphish.github.io/js/bootstrap.min.js"></script>

	</head>

	<body class="HolyGrail">

		<!-- Top navigation bar -->
		<nav id="main-navbar" class="navbar navbar-default HolyGrail-header">
	<div class="container-fluid">
		<!-- Brand and toggle get grouped for better mobile display -->
		<div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar-collapse" aria-expanded="false">
				<span class="sr-only">Toggle navigation</span>
				<!-- Burger menu -->
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a class="navbar-brand" href="http://hiphish.github.io">HiPhish's Workshop</a>
		</div>

		<!-- Collect the nav links, forms, and other content for toggling -->
		<div class="collapse navbar-collapse" id="bs-navbar-collapse">
			<!-- The list of navbar items -->
			<ul class="nav navbar-nav">
				<li class="dropdown active">
					<a href="/grid-framework" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">
						Grid Framework <span></span> <span class="sr-only">(current)</span>					</a>
					<ul class="dropdown-menu">

						<li>
							<a href="http://hiphish.github.io/grid-framework">
								Overview							</a>
						</li>

						<li class="divider" role="separator"></li>

						<li>
							<a href="http://hiphish.github.io/grid-framework/features">
								Features							</a>
						</li>

						<li class="active">
							<a href="http://hiphish.github.io/grid-framework/examples">
								Examples <span class="sr-only">(current)</span>							</a>
						</li>

						<li>
							<a href="http://hiphish.github.io/grid-framework/gallery">
								Gallery							</a>
						</li>

						<li>
							<a href="http://hiphish.github.io/grid-framework/showcase">
								Showcase							</a>
						</li>

						<li>
							<a href="http://hiphish.github.io/grid-framework/faq">
								FAQ							</a>
						</li>

						<li>
							<a href="http://hiphish.github.io/grid-framework/news">
								News							</a>
						</li>

						<li class="divider" role="separator"></li>

						<li>
							<a href="http://forum.unity3d.com/threads/144886-Grid-Framework-scripting-and-editor-plugins" target="_blank">
								Support							</a>
						</li>

						<li class="divider" role="separator"></li>

						<li>
							<a href="https://www.assetstore.unity3d.com/#/content/62498" target="_blank">
								Buy Now <span class="badge">35$</span>							</a>
						</li>
					</ul>
				</li>
				<li class="dropdown">
					<a href="https://gitlab.com/HiPhish/ntfs-clone" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">
						Open Source <span></span>					</a>
					<ul class="dropdown-menu">

						<li>
							<a href="https://gitlab.com/HiPhish/ntfs-clone" target="_blank">
								NTFS-Clone							</a>
						</li>

						<li>
							<a href="https://gitlab.com/HiPhish/roll" target="_blank">
								roll							</a>
						</li>

						<li>
							<a href="https://github.com/HiPhish/Newton-method" target="_blank">
								Newton's Method in C							</a>
						</li>

						<li>
							<a href="https://github.com/HiPhish/XeenTools" target="_blank">
								Xeen Tools							</a>
						</li>

						<li>
							<a href="https://github.com/HiPhish/Wolf3DExtract" target="_blank">
								Wolf3D Extract							</a>
						</li>

						<li>
							<a href="https://github.com/HiPhish/Game-Source-Documentation" target="_blank">
								Game Source Documentation							</a>
						</li>
					</ul>
				</li>
			</ul>
			<ul class="nav navbar-nav navbar-right">
				<li class=" ">
					<a href="/blog">
						Blog					</a>
				</li>
				<li class=" ">
					<a href="/about">
						About					</a>
				</li>
			</ul>
		</div><!-- /.navbar-collapse -->
	</div><!-- /.container-fluid -->
</nav>



<!-- All Bootstrap content must be inside a container div -->
<div class="flex-body">
	<!-- Sub-site navigation bar -->
	<div class="container">
		<nav id="sub-navbar" class="navbar navbar-default" >
	<div class="container-fluid">
		<!-- Brand and toggle get grouped for better mobile display -->
		<div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-subnavbar-collapse" aria-expanded="false">
				<span class="sr-only">Toggle navigation</span>
				<!-- Burger menu -->
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a class="navbar-brand" href="http://hiphish.github.io/grid-framework">Grid Framework</a>
		</div>

		<!-- Collect the nav links, forms, and other content for toggling -->
		<div class="collapse navbar-collapse" id="bs-subnavbar-collapse">
			<!-- The list of navbar items -->
			<ul class="nav navbar-nav navbar-right">
				<li class=" ">
					<a href="/grid-framework/features">
						Features					</a>
				</li>
				<li class=" active">
					<a href="/grid-framework/examples">
						Examples <span class="sr-only">(current)</span>					</a>
				</li>
				<li class=" ">
					<a href="/grid-framework/gallery">
						Gallery					</a>
				</li>
				<li class=" ">
					<a href="/grid-framework/showcase">
						Showcase					</a>
				</li>
				<li class=" ">
					<a href="/grid-framework/faq">
						FAQ					</a>
				</li>
				<li class=" ">
					<a href="/grid-framework/news">
						News					</a>
				</li>
				<li class=" ">
					<a href="http://forum.unity3d.com/threads/144886-Grid-Framework-scripting-and-editor-plugins" target="_blank">
						Support					</a>
				</li>
				<li class=" ">
					<!-- Wrap link-button in a 'div' to preserve layout -->
					<div class="navbar-btn">
						<a class="btn btn-default" href="https://www.assetstore.unity3d.com/#/content/4004" target="_blank">
							Buy <span class="badge">35$</span>						</a>
					</div>
				</li>
			</ul>
		</div><!-- /.navbar-collapse -->
	</div><!-- /.container-fluid -->
</nav>

	</div>

	
<style scoped="scoped">
			iframe {
				float:left;
				margin-right:1em;
				margin-bottom:2em;
				margin-left:1em;
				border-image-source:initial;
				border-image-slice:initial;
				border-image-width:initial;
				border-image-outset:initial;
				border-image-repeat:initial;
				border:1px solid #000000;
			}
		</style>
<div class="container">
<p>
				To help you get started Grid Framework comes with several examples
				showing you how to implement from scratch features commonly found in
				games, such as moving along a grid, using the grid for game logic like
				in a puzzle game, assembling a level or even extending Grid Framework
				with your own methods without touching the source code of Grid
				Framework itself.
			</p>
<p>
				All the examples are written both in C# and Java Script, when technically
				possible, and the source code has comments explaining the idea behind almost
				every line of code. I also have tutorial videos where I build those examples
				from scratch and expain the idea behind the code, for those of you who prefer
				learning by doing rather than having the source code served to them in one go.
			</p>
<p>
				Click a title to get to a playable build, or watch a video of
				me coding the example live. These videos were recorded at
				different points in Grid Framworks development and the
				interface and usability may appear more crude than it currently
				is.
			</p>
<hr/>
<iframe class="pull-right" src="http://www.youtube.com/embed/m9_efVi_tFs" title="YouTube video player"></iframe>
<h1 id="movement"><a href="./movement">Moving along a grid</a></h1>
<p>
				One of the most common uses for grids is movement. Maybe you have a tactical
				game, or a board game or you just want the old-school feel of tile based games.
				In this example we convert a sphere's world coordinates to grid coordinates and
				then move it in grid space before converting the result back to world space. As
				an extra touch we can limit the sphere to only stay within the bounds of the
				grid size. We need this because grids are infinitely large, so the sphere could
				wander off into infinity.
			</p>
<p>
				This example demonstrates one of the simplest and most common uses
				for Grid Framework: converting between coordinate systems. We take
				the object's current position, convert is to grid space, add a
				direction to it, convert the result back to world space and use
				that as the destination of our movement function.
			</p>
<!-- worldPosition = grid.GridToWorld(grid.WorldToGrid(worldPosition) + direction)); -->
<div class="highlight">
<pre>
<span class="n">worldPosition</span> <span class="p">=</span> <span class="n">grid</span><span class="p">.</span><span class="n">GridToWorld</span><span class="p">(</span><span class="n">grid</span><span class="p">.</span><span class="n">WorldToGrid</span><span class="p">(</span><span class="n">worldPosition</span><span class="p">)</span> <span class="p">+</span> <span class="n">direction</span><span class="p">));
</span></pre>
</div>
<p>
				In such a simple case it would make more sense to convert the
				possible directions to world space and store the results. Instead
				of converting back and forth all the time we could then just add
				the direction in world coordinates, saving a two steps in the
				process.  But this for demonstation purpose.
			</p>
<hr/>
<iframe class="pull-right" src="http://www.youtube.com/embed/m9_efVi_tFs" title="YouTube video player"></iframe>
<h1 id="obstacles"><a href="./obstacles">Moving with obstacles</a></h1>
<p>
				Moving around freely is nice, but let's make it more interesting by introducing
				obstacles. We could just use Unity's physics along with raycasting to see if our
				target location is free, but where would be the fun in that? Instead in this
				example we learn how to build a matrix where each entry corresponds to a tile
				in the grid. For the sake of simplicity we only store a bolean value, whether
				the tile is free or occupied, in the matrix, but we could easily extend the
				format to store more information, such as the terrain, the type of obstacle
				(wall, enemy, door, item) or even a reference to the object blocking our path.
			</p>
<p>
				The core of the example is a matrix of boolean values. We use Grid
				Framework to determine the size of the matrix.  How large does the
				matrix need to be? A few lines of code get the work done.
			</p>
<!-- var size = new int[2];                                                          -->
<!-- for(var i = 0; i < 2; i++){                                                     -->
<!--     // get the distance between both ends (in world units), divide it           -->
<!--     // by the spacing (to get grid units) and round down to the nearest integer -->
<!--     size[i] = Mathf.FloorToInt(Mathf.Abs(renderer.From[i] - renderer.To[i]) / grid.Spacing[i]); -->
<!-- }                                                                               -->
<div class="highlight">
<pre>
<span class="kt">var</span> <span class="n">size</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="m">2</span><span class="p">];</span>
<span class="k">for</span><span class="p">(</span><span class="kt">var</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">2</span><span class="p">;</span> <span class="n">i</span><span class="p">++){</span>
    <span class="c1">// get the distance between both ends (in world units), divide it</span>
    <span class="c1">// by the spacing (to get grid units) and round down to the nearest integer</span>
    <span class="n">size</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="n">Mathf</span><span class="p">.</span><span class="n">FloorToInt</span><span class="p">(</span><span class="n">Mathf</span><span class="p">.</span><span class="n">Abs</span><span class="p">(</span><span class="n">renderer</span><span class="p">.</span><span class="n">From</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">-</span> <span class="n">renderer</span><span class="p">.</span><span class="n">To</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">/</span> <span class="n">grid</span><span class="p">.</span><span class="n">Spacing</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>
</pre>
</div>
<p>
				And how do we find out the matrix position of a tile? Two lines of
				code do the job.
			</p>
<!-- var square = new int[2];                                                              -->
<!--     for(var i = 0; i < 2; i++){                                                       -->
<!--     square[i] = Mathf.FloorToInt(movementGrid.NearestCell(vec)[i]) - originSquare[i]; -->
<!-- }                                                                                     -->
<div class="highlight">
<pre>
<span class="kt">var</span> <span class="n">square</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="m">2</span><span class="p">];</span>
<span class="k">for</span><span class="p">(</span><span class="kt">var</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">2</span><span class="p">;</span> <span class="n">i</span><span class="p">++){</span>
    <span class="n">square</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="n">Mathf</span><span class="p">.</span><span class="n">FloorToInt</span><span class="p">(</span><span class="n">movementGrid</span><span class="p">.</span><span class="n">NearestCell</span><span class="p">(</span><span class="n">vec</span><span class="p">)[</span><span class="n">i</span><span class="p">])</span> <span class="p">-</span> <span class="n">originSquare</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>
</pre>
</div>
<hr/>
<iframe class="pull-right" src="http://www.youtube.com/embed/sXlagrglfQ8" title="YouTube"></iframe>
<h1 id="lights"><a href="./lights">lights-out puzzle game</a></h1>
<p>
				Here we learn how write a simple puzzle game where the goal is to turn all the
				lights off and every time you click a square that square and the four adjacent
				ones flip their colour. No tile knows anything about its surrounding tiles,
				making this game very flexible, you can have all sorts of crazy shapes and
				holes in it. This example uses delegates and events and is therefore only
				available in C#.
			</p>
<p>
				The core of this example is comparing the grid coordinates of the
				tiles to the one tile that was clicked to decide whether to switch
				colour. The logic is nicely encapsulated in a custom extension
				method and works for any type of grid:
			</p>
<!-- if(theGrid.IsAdjacent(transform.position, switchPosition)){ -->
<!--     //flip the state of this switch                         -->
<!--     isOn = !isOn;                                           -->
<!-- }                                                           -->
<div class="highlight">
<pre>
<span class="k">if</span><span class="p">(</span><span class="n">theGrid</span><span class="p">.</span><span class="n">IsAdjacent</span><span class="p">(</span><span class="n">transform</span><span class="p">.</span><span class="n">position</span><span class="p">,</span> <span class="n">switchPosition</span><span class="p">)){</span>
    <span class="c1">//flip the state of this switch</span>
    <span class="n">isOn</span> <span class="p">=</span> <span class="p">!</span><span class="n">isOn</span><span class="p">;</span>
<span class="p">}</span>
</pre>
</div>
<p>This extension method is not part of Grid Framework's API, but we can use it as if it were.</p>
<hr/>
<iframe class="pull-right" id="extending" src="http://www.youtube.com/embed/W_QteDtqHK4" title="YouTube"></iframe>
<h1>extending Grid Framework with your own methods</h1>
<p>
				This is a continuation of the above example where we extend the game to
				use a hexagonal grid. Needless to say we don't want to write almost the
				same script twice, so instead we will learn how to write our own method
				for a grid class that picks its implementation depending on the
				specific type of grid we use. Then we can use the same script for both
				rectangular, hexagonal and polar grids.
			</p>
<p>Here is the example of how it works for rectangular grids:</p>
<!-- public static bool IsAdjacent(this RectGrid grid, Vector3 position, Vector3 reference) { -->
<!--     // Convert to Grid Space first                                                       -->
<!--     var gPosition  = grid.WorldToGrid(position);  // The point we want to test           -->
<!--     var gReference = grid.WorldToGrid(reference); // The point we want to reference      -->
<!-- -->
<!--     var deltaX = Mathf.Abs(gPosition.x - gReference.x);                                  -->
<!--     var deltaY = Mathf.Abs(gPosition.y - gReference.y);                                  -->
<!--     var isAdjacent = deltaX <= 1.25f && deltaY <= 1.25f;                                 -->
<!--     var isDiagonal = -1.25f <= deltaX && 0.25f <= deltaY && isAdjacent;                  -->
<!-- -->
<!--     return isAdjacent && !isDiagonal;                                                    -->
<!-- }                                                                                        -->
<div class="highlight"><pre><span class="k">public</span> <span class="k">static</span> <span class="kt">bool</span> <span class="nf">IsAdjacent</span><span class="p">(</span><span class="k">this</span> <span class="n">RectGrid
</span> <span class="n">grid</span><span class="p">,</span> <span class="n">Vector3</span> <span class="n">position</span><span class="p">,</span> <span class="n">Vector3</span> <span class="n">reference</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Convert to Grid Space first</span>
    <span class="kt">var</span> <span class="n">gPosition</span>  <span class="p">=</span> <span class="n">grid</span><span class="p">.</span><span class="n">WorldToGrid</span><span class="p">(</span><span class="n">position</span><span class="p">);</span>  <span class="c1">// The point we want to test</span>
    <span class="kt">var</span> <span class="n">gReference</span> <span class="p">=</span> <span class="n">grid</span><span class="p">.</span><span class="n">WorldToGrid</span><span class="p">(</span><span class="n">reference</span><span class="p">);</span> <span class="c1">// The point we want to reference</span>

    <span class="kt">var</span> <span class="n">deltaX</span> <span class="p">=</span> <span class="n">Mathf</span><span class="p">.</span><span class="n">Abs</span><span class="p">(</span><span class="n">gPosition</span><span class="p">.</span><span class="n">x</span> <span class="p">-</span> <span class="n">gReference</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
    <span class="kt">var</span> <span class="n">deltaY</span> <span class="p">=</span> <span class="n">Mathf</span><span class="p">.</span><span class="n">Abs</span><span class="p">(</span><span class="n">gPosition</span><span class="p">.</span><span class="n">y</span> <span class="p">-</span> <span class="n">gReference</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
    <span class="kt">var</span> <span class="n">isAdjacent</span> <span class="p">=</span> <span class="n">deltaX</span> <span class="p">&lt;=</span> <span class="m">1.25f</span> <span class="p">&amp;&amp;</span> <span class="n">deltaY</span> <span class="p">&lt;=</span> <span class="m">1.25f</span><span class="p">;</span>
    <span class="kt">var</span> <span class="n">isDiagonal</span> <span class="p">=</span> <span class="p">-</span><span class="m">1.25f</span> <span class="p">&lt;=</span> <span class="n">deltaX</span> <span class="p">&amp;&amp;</span> <span class="m">0.25f</span> <span class="p">&lt;=</span> <span class="n">deltaY</span> <span class="p">&amp;&amp;</span> <span class="n">isAdjacent</span><span class="p">;</span>

    <span></span><span class="k">return</span> <span class="n">isAdjacent</span> <span class="p">&amp;&amp;</span> <span class="p">!</span><span class="n">isDiagonal</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<hr/>
<iframe class="pull-right" id="assembling" src="http://www.youtube.com/embed/lvYWbJ8ohkA" title="YouTube"></iframe>
<h1 id="level-design"><a href="./level-design">Assembling a level from text file</a></h1>
<p>
				In this example we create a breakout field by parsing a plain text file placing
				objects on the grid according to the position inside the file. This appoach
				has several advantages; most obviously it is faster and easier to design level
				in plain text rather than in an editor, you can add new levels very easily or
				allow players to add their own levels and you can reverse the process to write
				a text file from an ingame level editor. Instead of having a separate scene for
				each level we only need one scene, we can build new levels without having to
				worry about carrying the background or music from scene to scene, allowing for
				seamless transition.
			</p>
<p>
				The core of this example is the position of a character in the
				textfile, i.e. the row and column.  We use these text coordinates
				as grid coordinates and convert them to world coordinates.
			</p>
<!-- Vector3 targetPosition = levelGrid.GridToWorld(new Vector3(column, row, 0)); -->
<div class="highlight">
<pre>
<span class="n">Vector3</span> <span class="n">targetPosition</span> <span class="p">=</span> <span class="n">levelGrid</span><span class="p">.</span><span class="n">GridToWorld</span><span class="p">(</span><span class="k">new</span> <span class="n">Vector3</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="m">0</span><span class="p">));</span>
</pre>
</div>
<hr/>
<iframe class="pull-right" src="http://www.youtube.com/embed/QqUzcthkvcc" title="YouTube"></iframe>
<h1 id="snapping"><a href="./snapping">Runtime snapping</a></h1>
<p>
				If you want to allow the user to place object only on the grid, then this
				example is for you. For an extra challenge the grid has been rotated to create
				an isometric view effect. In reality you should rotat the camera instead.
			</p>
<p>
				Snapping is a two-step process: first we move the object to where
				the cursor is pointing, then we correct the position.
			</p>
<!-- transform.position = cursorWorldPoint; -->
<!-- grid.AlignTransform(transform);        -->
<div class="highlight">
<pre>
<span class="n">transform</span><span class="p">.</span><span class="n">position</span> <span class="p">=</span> <span class="n">cursorWorldPoint</span><span class="p">;</span>
<span class="n">grid</span><span class="p">.</span><span class="n">AlignTransform</span><span class="p">(</span><span class="n">transform</span><span class="p">);</span>
</pre>
</div>
<hr/>
<h1 id="endless"><a href="./endless">Seemingly endless grid</a></h1>
<p>
				Grids are infinity large when it come to calculations, but rendering an
				infinite amount of lines is impossible.  We will use a trick instead
				where we dynamically adjust the rendering range of the grid according
				to the camera.  The result is a seamless illusion that only renders the
				bare minimum and only updates when it has to.
			</p>
<!-- for (int i = 0; i < 3; i++) {                              -->
<!-- 	rangeShift[i] += transform.position[i] - lastPosition[i]; -->
<!-- }                                                          -->
<!-- -->
<!-- renderer.From += rangeShift;                               -->
<!-- renderer.To   += rangeShift;                               -->
<div class="highlight">
<pre>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">3</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="p">{</span>
    <span class="n">rangeShift</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">+=</span> <span class="n">transform</span><span class="p">.</span><span class="n">position</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">-</span> <span class="n">lastPosition</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>

<span class="n">renderer</span><span class="p">.</span><span class="n">From</span> <span class="p">+=</span> <span class="n">rangeShift</span><span class="p">;</span>
<span class="n">renderer</span><span class="p">.</span><span class="n">To</span>   <span class="p">+=</span> <span class="n">rangeShift</span><span class="p">;</span>
</pre>
</div>
<hr/>
<h1 id="terrain"><a href="./terrain">Terrain mesh generation</a></h1>
<p>
				We generate a mesh as a SimCity-like terrain using a plain text file as
				our height map. The file contains integer values which are then used to
				create mesh vertices which match up with grid vertices. Clicking a
				vertex reaises or lowers it. Everything is accompished be converting from
				grid coordinates to world coordinates.
			</p>
<hr/>
<h1 id="dial"><a href="./dial">Rotary dial</a></h1>
<p>
				A rotary dial as it could have been found on older phones. When the
				player clicks a sector of this polar grid the grid coordinates are
				used to determine which number was selected and use it to control
				the animation and print that number on the console.
			</p>
<hr/>
<h1 id="sliding"><a href="./sliding">Sliding puzzle</a></h1>
<p>
				Sometimes Unit's physics engine is too good for its own good and we need something
				simpler instead. In a sliding puzzle it is common for blocks to be touching each
				other with no space between, yet the player will expect there to be no friction.
				In this example we use Grid Framework to construct a matrix of cells and track for
				each cell whether it's free or occupied. Then we restrict movement of the blocks
				based on that information.
			</p>
<hr/>
<h1 id="snake"><a href="./snake">Snake game</a></h1>
<p>
				Another example of tile-base movement. The snake is made of several
				segments, linked together using a list. Only the head moves, the other
				segments follow their parent.
			</p>
<h1 id="vectrosity"><a href="./vectrosity">Vectrosity support</a></h1>
<p>
				Having some fun with Vectrosity and laser lines. The grids can move around or
				even change their properties at runtime.
			</p>
</div>

</div>



		<footer role="contentinfo" class="site-footer HolyGrail-footer">
<div class="container">
	<div class="col-md-8 footer-left">
		<a href="http://192.168.0.190:8000" title="HiPhish's Workshop">
			<img src="http://hiphish.github.io/images/footer/logo.png" alt="HiPhish's Workshop" />
		</a>
		<p class="text-muted">
			<a href="http://creativecommons.org/licenses/by-sa/4.0/"><img class="copyright-image" alt="Creative Commons Attribution-ShareAlike 4.0 International License" src="http://hiphish.github.io/images/footer/cc.svg" /></a>
			© 2015, licensed under <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a>
		</p>
	</div>  <!-- /.col-md-8 -->

	<div class="col-md-4 footer-right">
		<span class="pull-right">
			<a href="https://github.com/HiPhish" title="GitHub" target="_blank">
				<img  class="img-circle" src="http://hiphish.github.io/images/footer/github.png" alt="GitHub"/>
			</a>
			<a href="https://gitlab.com/u/HiPhish" title="GitLab" target="_blank">
				<img  class="img-circle" src="http://hiphish.github.io/images/footer/gitlab.png" alt="GitLab"/>
			</a>
		</span>  <!-- /.pull-right -->
	</div>  <!-- /.col-md-4 -->
	<p class="text-muted text-right"></p>
</div>  <!-- /.container -->		</footer>

	</body>
</html>