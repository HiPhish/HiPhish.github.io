<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>HiPhish's Workshop</title><link>http://hiphish.github.io/</link><description></description><atom:link href="http://192.168.0.190:8000/grid-framework/news/categories/progress/rss.xml" rel="self"></atom:link><lastBuildDate>Fri, 22 Apr 2016 00:00:00 +0200</lastBuildDate><item><title>Fixing what has been broken</title><link>http://hiphish.github.io/grid-framework/news/2016/04/22/fixing-broken/</link><description>&lt;p&gt;A quick  status update,  all the  examples and  the align  panel that  had been
broken by the  API change are  working  now again.  As I had  mentioned  when I
outlined the  plans for version 2.0,  this update  will break the API.  A major
version bump is an  opportunity to throw out old cruft,  decouple what does not
belong together and streamline everything that can be made simpler.&lt;/p&gt;
&lt;p&gt;Fixing the examples was  a good opportunity to see  just how broken the API has
become. For the most part the update was straight-forward. Here are the general
steps:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Grid Framework  now needs  to be  explicitly imported  to every script by the
&lt;code&gt;using&lt;/code&gt; directive in C# or &lt;code&gt;import&lt;/code&gt; in UnityScript.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;GF&lt;/code&gt; prefix needs to be dropped from every class name, there is no danger
of name conflicts anymore now that Grid Framework is namespaced.&lt;/li&gt;
&lt;li&gt;Some methods such as  aligning have been made into extension methods,  so one
has to import those as well.&lt;/li&gt;
&lt;li&gt;Anything rendering related has been moved to the renderer classes, so we need
a reference to  the grid's renderer as well.  In practice this means that the
&lt;code&gt;renderFrom&lt;/code&gt; and &lt;code&gt;renderTo&lt;/code&gt; of the grid became &lt;code&gt;From&lt;/code&gt; and &lt;code&gt;To&lt;/code&gt; of the
renderer.&lt;/li&gt;
&lt;li&gt;Cut out all cases  that cannot happen anymore,  such as non-relative units or
different grid planes for layered grids.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These five steps will generally be  enough to get most use-cases working again.
There is one problem though: we have lost a lot of polymorphism, but That's not
necessarily a bad thing.&lt;/p&gt;
&lt;p&gt;Let me explain:  when I originally  wrote Grid Framework it was only supporting
rectangular  grids,  and even those did  not have any shearing yet.  Everything
else was  just on  paper and  in my  head.  I had  imagined  grids  to be  more
polymorphic than  they really  are;  what I  mean by that  is that there really
isn't  much different  grids have  in common.  Take for  example the  rendering
range:  for a  rectangular grid  it makes perfect  sense that one  would have a
&lt;code&gt;Vector3&lt;/code&gt; for the lower and upper bound. The same goes for a herringbone shaped
hex grid.  It would also make sense  for a rectangular shaped hex grid,  except
that the individual values would have  to be integers instead of floating point
numbers. At least in that case we can kind of work around the issue by rounding
to integers, but where it makes absolutely no sense is for circular shapes like
the cone hex grids, or polar and spherical grids in general.&lt;/p&gt;
&lt;p&gt;The same  goes for  coordinate conversion.  I makes  sense the  have &lt;em&gt;the&lt;/em&gt; grid
coordinate system  in a  rectangular grid,  but what  is &lt;em&gt;the&lt;/em&gt;  grid coordinate
system in a hex grid?  In my case  it was  simply the  coordinate  system I had
implemented  first,  but  that  doesn't  mean  it  has  somehow  some  inherent
mathematical superiority.&lt;/p&gt;
&lt;p&gt;Aligning and scaling objects made even less sense for non-rectangular grids. In
Unity  the  &lt;code&gt;Transform&lt;/code&gt;  of  an  object  has a  scale,  which  is  a  &lt;code&gt;Vector3&lt;/code&gt;
representing the scale of a cuboid. How do you fit a cuboid into a hex gird? Or
even in a rectangular grid with shearing? You don't.&lt;/p&gt;
&lt;p&gt;Putting such tasks into  a general &lt;code&gt;Grid&lt;/code&gt; class  makes no sense and no one will
use it from inside the grids that do j ust something for the sake of satisfying
the API.  Even though we have lost some  polymorphism, we have only lost it for
things that are useless anyway.&lt;/p&gt;
&lt;p&gt;If you still think that &lt;em&gt;you&lt;/em&gt; have the right solution for your specific problem
domain you can  easily add it to the grids as an extension method.  I have done
the same for the methods that have been removed from the grids as well.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HiPhish</dc:creator><pubDate>Fri, 22 Apr 2016 00:00:00 +0200</pubDate><guid>tag:hiphish.github.io,2016-04-22:grid-framework/news/2016/04/22/fixing-broken/</guid></item><item><title>One unified directory</title><link>http://hiphish.github.io/grid-framework/news/2016/04/20/one-directory/</link><description>&lt;p&gt;In version  1.x Grid Framework  has been distributed  over several directories:
&lt;em&gt;Plugins&lt;/em&gt;,  &lt;em&gt;Editor&lt;/em&gt;,  &lt;em&gt;WebPlayerTemplates&lt;/em&gt;  and  &lt;em&gt;GridFamework&lt;/em&gt;.  I  did  this
because  it seemed  logical to  split the  content by purpose,  but some people
disagreed with my choice,  so for version 2.0  everything will unify everything
in one directory.&lt;/p&gt;
&lt;p&gt;Here is what it looked like before:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
Assets
├─Editor
│ └─Grid Famework
│   └─...
├─Grid Framework
│ └─...
├─Plugins
│ └─Grid Famework
│   └─...
└─WebPlayerTemplates
  └─Grid Framework Documentation
    └─...
&lt;/pre&gt;
&lt;p&gt;And this is what it looks like now:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
Assets
└─Plugins
  └─Grid Famework
    ├─Changelog.md
    ├─readme.txt
    ├─Editor
    │ └─...
    ├─Examples
    │ └─...
    ├─Extensions
    │ └─...
    ├─Grids
    │ └─...
    ├─Interfaces
    │ └─...
    ├─Matrices
    │ └─...
    ├─Playmaker Actions
    │ └─...
    ├─Renderers
    │ └─...
    ├─Rendering
    │ └─...
    ├─Resources
    │ └─...
    ├─Test
    │ └─...
    └─Vectors
      └─...
&lt;/pre&gt;
&lt;p&gt;Now all  of Grid Framework  is confined to  one directory i nside your project.
There is one  downside though:  UnityScript source files  are compiled after C#
source files in the &lt;em&gt;Plugins&lt;/em&gt; directory. This means that examples can no longer
be written  in UnityScript.  My choice was  to either rewrite  the  UnityScript
examples or  give up  the unified  directory.  I have  chosen  the former,  the
examples are simple enough  that even people  unfamiliar with C# can understand
them and most of the examples cannot be implemented in UnityScrip anyway. In my
opinion Unity has done us a disfavour by  having two languages when one of them
is a second-class citizen, and pushing that one as the default.&lt;/p&gt;
&lt;p&gt;Finally,  I still haven't figured out what  to do with the &lt;em&gt;WebPlayerTemplates&lt;/em&gt;
directory. I have been distributing the documentation in that directory because
otherwise Unity would try to compile  the JavaScript files as UnityScript files
and  fail.   It  is  unacceptable   to  publish  a  framework  withoutt offline
documentation,  but at the  same time I  don't like  abusing the  directory and
spamming  people's project.  One idea  would be  to ZIP  the documentation  and
include it like that. Another possibility would be to change the file extension
of every JavaScript file to for example  &lt;code&gt;.txt&lt;/code&gt;,  but then I would also have to
change every reference in every HTML and JavaScript file as well.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HiPhish</dc:creator><pubDate>Wed, 20 Apr 2016 00:00:00 +0200</pubDate><guid>tag:hiphish.github.io,2016-04-20:grid-framework/news/2016/04/20/one-directory/</guid></item><item><title>Managing renderers</title><link>http://hiphish.github.io/grid-framework/news/2016/04/13/managing-renderers/</link><description>&lt;p&gt;Breaking the rendering  task out of the grid  into its own dedicated class is a
good first step, but if all we have gained from this is several smaller classes
we haven't  really gained much.  In this entry  I will discuss  how version 2.0
gives you more control over the rendering process.&lt;/p&gt;
&lt;div class="section" id="priority"&gt;
&lt;h2&gt;Priority&lt;/h2&gt;
&lt;p&gt;Setting the order in  which grids are rendered  when every grid can be rendered
only once is simple,  just let their position in the world handle it.  However,
in version 2.0 the rendering will be separated from the grid itself, so we need
proper control over the order.&lt;/p&gt;
&lt;p&gt;Every renderer has a &lt;code&gt;Priority&lt;/code&gt; property, that's an integer value which is used
to sort renderers  in a list  maintained  by the camera.  If you  have multiple
renderers per grid you will want to  have control over which ones render on top
of which ones. In version 1.x to achieve that effect you would need to create a
whole new grid and then make it match the first one.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;Managing renderers&lt;/h2&gt;
&lt;p&gt;Every renderer created is  registered with a central manager class.  This class
is static so you don't have to  instantiate anything and renderers take care of
this process themselves. The entire thing works on autopilot and you don't have
to concern yourself with it if you don't want to.&lt;/p&gt;
&lt;p&gt;However,  if you  do want  to you  can access  all the renderers  directly  and
manipulate them.  Why would you want to do that? You could for example take the
lines computed by the renderer and instead of having Grid Framework render them
you send them to your own code.  This gives you 100% control  over every single
line.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="rendering-lines"&gt;
&lt;h2&gt;Rendering lines&lt;/h2&gt;
&lt;p&gt;As with version 1.x every camera will need a script attached to it. What is new
is how the script works: in version 1.x it was really just a small wrapper that
called the grid's rendering method.  This method has been moved into the camera
script instead. If you don't like the default implementation you can write your
own replacement now,  while in version 1.x  you would have had  to modified the
grid script instead.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="one-caveat-overlapping-grids"&gt;
&lt;h2&gt;One caveat: overlapping grids&lt;/h2&gt;
&lt;p&gt;There is  one problem  I have  not been  able to solve:  sorting  lines back to
front.  What this means is that  if two grids are overlapping,  then lines that
are in front of other lines need to be drawn on top of them.  Implementing this
sort  of  drawing  would   be too  slow to  be useful,  so you  are better  off
generating meshes from  the lines and letting Unity handle the rest from there.
That's what Vectrosity is doing and it works very well. I'm sorry, but there is
no good  solution for  this  problem,  short of  re-inventing  what  Vectrosity
already does.  This is why Vectrosity support  will remain in version 2.0 as an
extension method to renderers.&lt;/p&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HiPhish</dc:creator><pubDate>Wed, 13 Apr 2016 00:00:00 +0200</pubDate><guid>tag:hiphish.github.io,2016-04-13:grid-framework/news/2016/04/13/managing-renderers/</guid></item><item><title>Revisiting coordinate systems</title><link>http://hiphish.github.io/grid-framework/news/2016/03/29/revisiting-coordinate-systems/</link><description>&lt;p&gt;There are  basically two types  of grid in Grid Framework: 3D grids and layered
grids.  3D grids use all three dimensions,  these are rectangular and spherical
grids,  while layered grids are 2D  grids stacked  on top of  each other  for a
third dimension.  In this  post I  will explain  how the  coordinate systems of
layered girds will change in version 2.0.&lt;/p&gt;
&lt;div class="section" id="how-it-is-in-version-1-x"&gt;
&lt;h2&gt;How it is in version 1.x&lt;/h2&gt;
&lt;p&gt;Layered grids are  2D grids that are extended by a third dimension.  This extra
dimension is the &lt;em&gt;layer&lt;/em&gt;. The question is how such a grid should be embedded in
the surrounding 3D space.  We could map the X- and Y-coordinates of the grid to
the X- and Y-coordinates of the 3D space and map the layer to the Z-coordinate.
Or we could use any other permutation.&lt;/p&gt;
&lt;p&gt;For a 2D game it  makes sense if the X- and Y-coordinates of both spaces match.
But what if we want to make a top-down 3D game? It would make more sense to map
the X- and any Y-coordinates  to the world's X- and  Z-coordinates respectively
and the layer to the Y-coordinate. And this is where the problem starts.&lt;/p&gt;
&lt;p&gt;Unit's coordinate system is left-handed,  this means that if you take your left
hand  and have the  thumb be the first axis,  the index finger the second axis,
then your middle finger is the third axis and it is pointing away from you.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
Y
|   Z
|  /   A left-handed coordinate system
| /
|/
+--------X
&lt;/pre&gt;
&lt;p&gt;If we use the X-axis  as the first one,  the Z-axis as  the second one  and the
Y-axis  as the  third axis our coordinate system becomes right-handed.  We have
the choice  between either  changing the  handedness or  having a  Y-axis  that
points downwards. In version 1.x I had chosen the former.&lt;/p&gt;
&lt;p&gt;If you  can't see  the change  in handedness try  it out,  take your left hand,
point the thumb right,  the middle finger up  and your index  finger will point
towards you instead of away from you.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="how-it-will-be-in-version-2-0"&gt;
&lt;h2&gt;How it will be in version 2.0&lt;/h2&gt;
&lt;p&gt;Changing handedness  really causes more problems than it supposedly solves,  so
this will be completely scrapped, every coordinate system is left-handed.  In a
top-down game  the X-axis of the grid will map to the Z-axis of the world,  the
Y-axis to the X-axis and the Z-axis to the Y-axis.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
Z
|   X
|  /   Rotated 60° about the (1, 1, 1) axis
| /
|/
+--------Y
&lt;/pre&gt;
&lt;p&gt;There are good mathematical reasons for this, but the important part is that if
we keep applying this transformation we cycle through the different left-handed
permutations. This can easily be implemented as a matrix transformation.&lt;/p&gt;
&lt;p&gt;So that raises another question, if all we are doing here is rotating the grid,
why don't we  just rotate the  grid using  Unity's own capabilities?  Why do we
even have a  grid plane in  the first place? That's what I thought as well,  so
the grid plane  has been scrapped  completely for version 2.0,  you just rotate
the grid the way you like it.&lt;/p&gt;
&lt;p&gt;Finally,  in version 1.x  I also tried  to match  the grid-coordinates with the
world coordinates,  i.e. what would  be the  Y-coordinate  in an XY-grid  would
become the  Z-coordinate in an XZ-grid.  I did this because  I thought it would
make more sense when you write your game-logic in an XZ-coordinate system,  but
that was  making  too  many assumptions  and just  made  everything  even  more
complicated.&lt;/p&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HiPhish</dc:creator><pubDate>Tue, 29 Mar 2016 00:00:00 +0200</pubDate><guid>tag:hiphish.github.io,2016-03-29:grid-framework/news/2016/03/29/revisiting-coordinate-systems/</guid></item><item><title>Official extension methods</title><link>http://hiphish.github.io/grid-framework/news/2016/03/05/official-extensions/</link><description>&lt;p&gt;If you have been  following my updates  in regards to version 2.0 you will have
noticed that  one of the themes  has been slimming  down the API.  Some things,
such as the &lt;code&gt;renderGrid&lt;/code&gt; flag are easy to replace  with something  more general
or trivial to  replicate with one or  two lines of code.  Other methods however
are non-trivial to implement,  useful to have and general enough to included in
the framework.&lt;/p&gt;
&lt;p&gt;This is where  extension methods come in.  Extension methods are a C# syntactic
sugar  feature that  allows us  to write new methods  that can be treated as if
they were instance methods of another class&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// Define the extension method&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;GetTwice&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt; &lt;span class="n"&gt;MyClass&lt;/span&gt; &lt;span class="n"&gt;instance&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;once&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt; &lt;span class="p"&gt;*&lt;/span&gt; &lt;span class="n"&gt;once&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// Use the method&lt;/span&gt;
&lt;span class="n"&gt;MyClass&lt;/span&gt; &lt;span class="n"&gt;myInstance&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;four&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;myInstance&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GetTwice&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Extensions will be used for all the methods that are useful to have,  but don't
rally belong  into the class itself.  Extensions reside  in their own namespace
and need  to be  explicitly  imported  using  a &lt;code&gt;using&lt;/code&gt; statement.  Here is  a
practical example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="nn"&gt;GridFramework.Grids&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="nn"&gt;GridFramework.Extensions.Nearest&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;RectGrid&lt;/span&gt; &lt;span class="n"&gt;grid&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;Vector3&lt;/span&gt; &lt;span class="n"&gt;vertex&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;grid&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;NearestVertex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Vector3&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;one&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                                    &lt;span class="n"&gt;RectGrid&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CoordinateSystem&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Grid&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;While I was at it I also dropped the &lt;code&gt;W&lt;/code&gt; and &lt;code&gt;G&lt;/code&gt; suffixes,  instead you have to
pass a  coordinate  system as  an argument.  If you  don't want  to  specify an
argument every time you can write an extension method of your own.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="nn"&gt;GridFramework.Grids&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="nn"&gt;GridFramework.Extensions.Nearest&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="nf"&gt;NearestVertex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt; &lt;span class="n"&gt;RectGrid&lt;/span&gt; &lt;span class="n"&gt;grid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Vector3&lt;/span&gt; &lt;span class="n"&gt;position&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;system&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;RectGrid&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CoordinateSystem&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Grid&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;grid&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;NearestVertex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;grid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;system&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Extension methods allow me to group methods by their problem domain rather than
the class they belong to.  Namespacing them also means t hey won't clutter your
completion suggestions unless you import them explicitly.&lt;/p&gt;
&lt;p&gt;For  now  the  methods  for alignment,  scaling,  finding  nearest  points  and
Vectrosity support will be made into official extension methods.  This will cut
down the size of  the grid classes  massively down: grids will only store their
instance methods,  relevant enumerations,  accessors and  coordinate conversion
methods.  In the  future new  extension  methods  can be  added with  their own
namespace if the need arises.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HiPhish</dc:creator><pubDate>Sat, 05 Mar 2016 00:00:00 +0100</pubDate><guid>tag:hiphish.github.io,2016-03-05:grid-framework/news/2016/03/05/official-extensions/</guid></item><item><title>Keeping the renderers updated and efficient</title><link>http://hiphish.github.io/grid-framework/news/2016/02/02/keeping-renderers-updated/</link><description>&lt;p&gt;Rendering a grid is a three-step process: first we count how many lines we need
to render and  allocate the space needed,  then we compute their end points and
finally we send them to Unity to do its thing. In the earliest versions of Grid
Framework these three  steps had been done every frame.  Since arrays in C# are
heap objects this would send the garbage  collector in overdrive for very large
grids.&lt;/p&gt;
&lt;p&gt;An optimisation  was put in  place very quickly:  if the  grid has  not changed
simply re-use  the existing points.  If the points have changed,  but not their
amount re-use the array and only overwrite the values in it.  This could be the
case for example when  you change the spacing of a rectangular grid,  the lines
change, but their amount stays the same.&lt;/p&gt;
&lt;p&gt;Since back then  there were no  separate renderer classes  everything was  done
inside the grid class and I had full control over everything going on,  but now
we need some way for the renderer object to know when the grid has changed. The
obvious solution would be  to keep a local copy of every public property of the
grid in the renderer and compare the copy to the original every frame:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// private variables in the renderer&lt;/span&gt;
&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;spacing&lt;/span&gt;  &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Grid&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Spacing&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;shearing&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Grid&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Shearing&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="nf"&gt;GridHasChanged&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;spacing&lt;/span&gt; &lt;span class="p"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;Grid&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Spacing&lt;/span&gt; &lt;span class="p"&gt;||&lt;/span&gt; &lt;span class="n"&gt;shearing&lt;/span&gt; &lt;span class="p"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;Grid&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Shearing&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is pretty simple,  but it wastes memory by keeping basically a second copy
of the grid and we would still have to run the method every frame. There has to
be a better solution in which  the renderer does not not have to poll the grid,
but the renderer gets notified by the grid instead.&lt;/p&gt;
&lt;div class="section" id="subscribing-to-grid-events"&gt;
&lt;h2&gt;Subscribing to grid events&lt;/h2&gt;
&lt;p&gt;C# offers such a feature  with events and delegates.  We define an event in the
grid class and fire  it from the grid.  The renderer can subscribe to the event
by setting a method to run when the grid fires the event.  This distributes the
work  neatly  between  grid  and  renderer:  the  grid  does not  know who  has
subscribed  to it  and  is only  concerned  with  firing the  event,  while the
renderer takes on the responsibility of performing the actual action.&lt;/p&gt;
&lt;p&gt;The  renderer  subscribes  when  it  is  enabled  and  unsubscribes when  it is
disabled.  The syntax is a bit odd:  the grid exposes  an event type and we add
the delegates of  the method to call to it using the &lt;code&gt;+=&lt;/code&gt; operator.  A delegate
is  a  method  reference,  similar to  a function  pointer in  the C-family  of
languages.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// The arguments of the event are encapsulated in their own type&lt;/span&gt;
&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="nn"&gt;SpacingEventArgs&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;GridFramework&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Grids&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;RectGrid&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SpacingEventArgs&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// Subscribe when the renderer gets enabled&lt;/span&gt;
&lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;OnEnable&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Grid&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SpacingChanged&lt;/span&gt; &lt;span class="p"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;OnSpacingChanged&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// Unsubscribe when the renderer gets disabled&lt;/span&gt;
&lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;OnDisable&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Grid&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SpacingChanged&lt;/span&gt; &lt;span class="p"&gt;-=&lt;/span&gt; &lt;span class="n"&gt;OnSpacingChanged&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// The action to perform&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt; &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;OnSpacingChanged&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;object&lt;/span&gt; &lt;span class="n"&gt;source&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;SpacingEventArgs&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// Code goes here...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;These facilities are public and available to users as well if they want to
subscribe.&lt;/p&gt;
&lt;p&gt;Using events for everything would be overkill though, for changes to the
renderer itself we still use regular private methods inside the renderer class:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// Public accessor for member variable&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Vector3&lt;/span&gt; &lt;span class="n"&gt;From&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;get&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;_from&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;previous&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;_from&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;_from&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Vector3&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Min&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;To&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;OnFromChanged&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;previous&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;private&lt;/span&gt; &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;OnFromChanged&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Vector3&lt;/span&gt; &lt;span class="n"&gt;previous&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// Code goes here...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We  cannot  subscribe  to these  changes,  nor should  we.  The changes  to the
renderer  affect only  the points  computed,  it's a  black box  where you  get
coordinates out and nothing more.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="ok-we-know-the-grid-has-changed-what-now"&gt;
&lt;h2&gt;OK, we know the grid has changed, what now?&lt;/h2&gt;
&lt;p&gt;Knowing that something has changed is the first step, the next one is to decide
what to do with that knowledge. The easiest solution is to just re-count and
re-compute everything. If the amount of lines has not changed we don't need to
allocate a new array, but other than that we don't save any work.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;numberOfLines&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;Vector3&lt;/span&gt;&lt;span class="p"&gt;[][]&lt;/span&gt; &lt;span class="n"&gt;lines&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lines&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Length&lt;/span&gt; &lt;span class="p"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;numberOfLines&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// allocate a new array&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We could instead use the knowledge of &lt;em&gt;what&lt;/em&gt; has  changed to make very specific
adjustments which  might perform  better.  If we  take rectangular  grids as an
example again,  a change in spacing can be replicated by multiplying all points
with a number of matrices.  Profiling the two  possibilities has shown that the
more complicated  approach performs  about  twice as well  on a 100 × 100 × 100
grid.  The extra effort  is not always worth it though,  and if you are writing
your own renderers  you should profile  the performance  of the  naive approach
first.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="it-s-not-that-simple-though"&gt;
&lt;h2&gt;It's not that simple though&lt;/h2&gt;
&lt;p&gt;Ideally this would be it, but Unity throws a few roadblocks in my way. For one,
there is no  way to subscribe  reliably outside  of play  mode.  This means  in
editor mode we have to re-count and re-compute the points anyway.  There are no
new arrays allocated if we don't have to, so there is that.  Performance in the
editor is not  as crucial and  I haven't  noticed any impact  on the editor for
reasonably sized grids, so this shouldn't be an issue in practice.&lt;/p&gt;
&lt;p&gt;Another roadblock  is that  there is  no way  to be  notified when  an object's
&lt;code&gt;Transform&lt;/code&gt; changes. We have to do it the hard way:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;private&lt;/span&gt; &lt;span class="n"&gt;Vector3&lt;/span&gt;    &lt;span class="n"&gt;_oldPosition&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt; &lt;span class="n"&gt;Quaternion&lt;/span&gt; &lt;span class="n"&gt;_oldRotation&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="nf"&gt;TransformHasChanged&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="k"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="p"&gt;|=&lt;/span&gt; &lt;span class="n"&gt;_oldPosition&lt;/span&gt; &lt;span class="p"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;transform&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;position&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="p"&gt;|=&lt;/span&gt; &lt;span class="n"&gt;_oldRotation&lt;/span&gt; &lt;span class="p"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;transform&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rotation&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;_oldPosition&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;transform&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;position&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;_oldRotation&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;transform&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rotation&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;These workarounds have the same drawbacks as discussed above, but they are much
smaller now that they are reduced to just two cases.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="only-work-when-enabled"&gt;
&lt;h2&gt;Only work when enabled&lt;/h2&gt;
&lt;p&gt;The final optimisation  is to not  work at al l when not necessary:  a renderer
will not perform any of  these tasks when it is disabled.  This is the simplest
of all, we unsubscribe from all events, the rendering system skips the renderer
and nothing  is drawn.  Aside from  its  memory footprint  the renderer  has no
impact on the game.  Disabling a renderer is done the same way as for any other
Unity script,  either by  unchecking the  box in  the editor  or by setting the
&lt;code&gt;enabled&lt;/code&gt;  member  variable  to &lt;code&gt;false&lt;/code&gt;.  This  was  not  possible  in previous
versions where the renderer and the grid were one and the same object.&lt;/p&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HiPhish</dc:creator><pubDate>Tue, 02 Feb 2016 00:00:00 +0100</pubDate><guid>tag:hiphish.github.io,2016-02-02:grid-framework/news/2016/02/02/keeping-renderers-updated/</guid></item><item><title>Namespaces for everything</title><link>http://hiphish.github.io/grid-framework/news/2016/01/25/namespace-everything/</link><description>&lt;p&gt;Releasing a new major  version is a good  opportunity to  say goodbye  to older
versions of your environment.  Version 2.0 will require at  least Unity version
5.0, which will free me from the restrictions of previous versions.&lt;/p&gt;
&lt;p&gt;One particular  restriction has  been the  lack of namespaces for  classes that
inherit  from  &lt;code&gt;MonoBehaviour&lt;/code&gt;.  I don't  know anymore  which version  had that
problem,  but essentially any  sub-class of  &lt;code&gt;MonoBehaviour&lt;/code&gt; had to  be in  the
global namespace and  this lead to the ugly &lt;code&gt;GF&lt;/code&gt; prefix everywhere.  The prefix
has been dropped  now from all  the grid  classes and  they are  in a  properly
namespaced order.&lt;/p&gt;
&lt;p&gt;The root namespace is &lt;code&gt;GridFramework&lt;/code&gt;,  there a number of  other namespaces are
nested in it.  Grids reside in the &lt;code&gt;GridFramework.Grids&lt;/code&gt; namespace, their class
names are the  same except for the  &lt;code&gt;GF&lt;/code&gt; prefix.  This is what a  piece of user
code looks like without namespaces:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="nn"&gt;UnityEngine&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;GFRectGrid&lt;/span&gt; &lt;span class="n"&gt;grid&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;Vector3&lt;/span&gt; &lt;span class="n"&gt;gridPosition&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;grid&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;WorldToGrid&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Vector3&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;3&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Let's use namespaces instead:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="nn"&gt;UnityEngine&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="nn"&gt;GridFramework.Grids&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;RectGrid&lt;/span&gt; &lt;span class="n"&gt;grid&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;Vector3&lt;/span&gt; &lt;span class="n"&gt;gridPosition&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;grid&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;WorldToGrid&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Vector3&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;3&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This may not  seem like much,  but keep in  mind that the  standalone renderers
introduce a number  of new classes  as well,  if every one  of those had the be
prefixes as well it would get very ugly very quickly.  Renderers reside  in the
&lt;code&gt;GridFramework.Renderers&lt;/code&gt;  namespace  where  every  type of  grid  has its  own
sub-namespace on top of that.  So if we want to use a rhombic hex-grid renderer
we use the  &lt;code&gt;GridFramework.Renderers.Hexagonal.Rhombic&lt;/code&gt; class.  Why this  extra
namespace in between?  All renderers  inherit from  a common grid-specific base
class,  e.g.  &lt;code&gt;GridFramework.Renderers.Hexagonal.Renderer&lt;/code&gt;,  which in  turn all
inherit from a common base class &lt;code&gt;GridFramework.Renderers.Renderer&lt;/code&gt;. This means
that in order to implement your own renderer you already have a very good basis
to build upon.&lt;/p&gt;
&lt;p&gt;There might be more  namespaces down the line,  but they won't be as important.
If you are concerned that  declarations might get  too large use the C# &lt;code&gt;using&lt;/code&gt;
directive:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="nn"&gt;Renderer&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;GridFramework&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Renderers&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Hexagonal&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Renderer&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;MyHexRenderer&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Renderer&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And finally,  when everything is nicely  tucked away in different namespaces it
is much easier to find what you are looking for in the documentation.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HiPhish</dc:creator><pubDate>Mon, 25 Jan 2016 00:00:00 +0100</pubDate><guid>tag:hiphish.github.io,2016-01-25:grid-framework/news/2016/01/25/namespace-everything/</guid></item><item><title>First major step towards 2.0</title><link>http://hiphish.github.io/grid-framework/news/2016/01/13/first-step-to-20/</link><description>&lt;p&gt;I have  now finished the first major task  towards version 2.0:  extracting the
renderers into their  own class.  Until now the  task of rendering the grid was
part of the grid class, this made the classes much larger and it was impossible
to add one's own rendering shapes without modifying the grids themselves.&lt;/p&gt;
&lt;p&gt;The new  approach is  much cleaner  and more  in the spirit  of object-oriented
programming:  The grid itself  does not  render anything at all.  It provides a
public interface  that has all  the information needed for  &lt;em&gt;another&lt;/em&gt; object to
compute all  the points necessary.  This second  object is the &lt;em&gt;renderer&lt;/em&gt;, it's
another &lt;code&gt;Component&lt;/code&gt; attached to a &lt;code&gt;GameObject&lt;/code&gt;. In order to create a new custom
shape you would just have to write a new renderer class and use the same public
interface I used as well.  This means you get to use exactly the same API I was
using as well, no hacking around in the source or using undocumented API.&lt;/p&gt;
&lt;p&gt;I was glad to find that the public  API provided in version 1.x is all I needed
to rewrite all  existing renderers.  This means that if  you already  know Grid
Framework there is  nothing new to learn.  There are still  some questions open
about how exactly to handle renderers;  currently all renderers are components,
that's a very simple approach but it  has one nasty limitation: you cannot have
more than one renderer of every type attached to the same &lt;code&gt;GameObject&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Let's say you have two wizards and you want to visualise the area of effect for
their spells.  It would make  sense to use  two different renderers of the same
type on  the  same grid,  one for each wizard.  However,  since you cannot have
more than one renderer per grid you  would have to make a duplicate of the grid
&lt;code&gt;GameObject&lt;/code&gt;.  One solution  would  be to  drop the  &lt;code&gt;Component&lt;/code&gt; idea  and make
renderers just regular classes,  but then we lose the ability to set properties
in the inspector, and that is unacceptable.&lt;/p&gt;
&lt;p&gt;The best idea I have so far is  to strike a balance between those two concepts:
there will be a  container type for  renderers that  can contain  any amount of
renderers.  The container  will be  a &lt;code&gt;Component&lt;/code&gt;  with a very  small inspector
interface that  contains a sort  of foldout  for every renderer.  The renderers
define their  own inspector  interface which  is then  rendered as  part of the
container's interface.&lt;/p&gt;
&lt;p&gt;The downside to this  is that the renderers  are now concerned  with two tasks:
rendering the grid and their inspector interface.  It's small price to pay, but
still. Maybe I will be able to come up with something better in the meantime.&lt;/p&gt;
&lt;div class="section" id="update"&gt;
&lt;h2&gt;Update&lt;/h2&gt;
&lt;p&gt;Well, this has been a waste of time:  turns out that you can have more than one
component of the same type per &lt;code&gt;GameObject&lt;/code&gt;. I think that's the way to go then.
Here is a  screenshot of it:  there is one  underlying main  grid which  uses a
rectangular shape and two cone grids.  Every renderer has its  own setting like
colour, position and so on.&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="Hexagonal grid with two hexagonal grids inside it" class="img-responsive" src="http://hiphish.github.io/grid-framework/news/2016/01/13/first-step-to-20/images/multi-renderers.png"/&gt;
&lt;p class="caption"&gt;One wizard is  about to cast  the fireball  spell while another  is about to
cast an ice-wall spell.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HiPhish</dc:creator><pubDate>Sun, 17 Jan 2016 00:00:00 +0100</pubDate><guid>tag:hiphish.github.io,2016-01-13:grid-framework/news/2016/01/13/first-step-to-20/</guid></item><item><title>Spherical grid coordinate systems</title><link>http://hiphish.github.io/grid-framework/news/2015/11/30/spheric-coordinate-system/</link><description>&lt;p&gt;Progress has been better than expected and spheric grids are practically done.
This is a good opportunity to take a look at the coordinate systems in spheric
grids.&lt;/p&gt;
&lt;p&gt;The first application for spheric grids that came to my mind was using them
along the surface of a planet. The coordinate system used for navigation on
Earth is called the &lt;em&gt;geographic coordinate system&lt;/em&gt;, a point is identified using
its altitude (distance from the planet's surface), the longitude and the
latitude.&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="Geographic coordinate system schematic" class="img-responsive" src="http://hiphish.github.io/grid-framework/news/2015/11/30/spheric-coordinate-system/images/geographic-coordinates.png"/&gt;
&lt;/div&gt;
&lt;p&gt;The latitude is the angle between the vector and the equatorial plane, the
longitude is the angle between the vector and the plane of the prime meridian.
This coordinate system has signed coordinates: points beneath the surface have
negative altitude, the southern hemisphere has negative latitude and the
western hemisphere has negative longitude.&lt;/p&gt;
&lt;p&gt;The other coordinate system is &lt;em&gt;spherical coordinates&lt;/em&gt;. This time we use the
distance from the origin of the grid, the polar angle between the vector and
the polar axis and the azimuth angle around the prime meridian.&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="Spherical coordinate system schematic" class="img-responsive" src="http://hiphish.github.io/grid-framework/news/2015/11/30/spheric-coordinate-system/images/spherical-coordinates.png"/&gt;
&lt;/div&gt;
&lt;p&gt;This coordinate system has no negative coordinates: the polar angle at the
equator is &lt;span class="formula"&gt;&lt;i&gt;π&lt;/i&gt; ⁄ 2&lt;/span&gt; (90°) and moving south increases the angle up to &lt;span class="formula"&gt;&lt;i&gt;π&lt;/i&gt;&lt;/span&gt; (180°) at
the south pole, the azimuth angle works like polar coordinates and wraps around
after a full circle.&lt;/p&gt;
&lt;p&gt;There is also the &lt;em&gt;grid coordinate system&lt;/em&gt;, it is the same as spherical except
that coordinates are given in relative grid lines rather than absolute distance
and angles.&lt;/p&gt;
&lt;div class="section" id="update-coming-soon"&gt;
&lt;h2&gt;Update coming soon&lt;/h2&gt;
&lt;p&gt;So far everything looks in order, I plan on submitting the update this week if
everything goes well. I still have some more testing to run before I can
declare it production ready, then it's up the Asset Store team. Spheric grids
have been on the to-do list since the very start, so seeing them finally make
it into Grid Framework is a big step for me and I am looking forward to seeing
them in your games.&lt;/p&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HiPhish</dc:creator><pubDate>Mon, 30 Nov 2015 00:00:00 +0100</pubDate><guid>tag:hiphish.github.io,2015-11-30:grid-framework/news/2015/11/30/spheric-coordinate-system/</guid><category>spheric</category><category>coordinate-system</category></item><item><title>Spheric grid rendering</title><link>http://hiphish.github.io/grid-framework/news/2015/11/27/spheric-rendering/</link><description>&lt;p&gt;I have been working on the next type of grid: spheric grids. Think latitude and
longitude like on Earth. Here is a GIF of a rendered grid rotating around its
axis. Don't worry about the framerate, that's how the image was recorded to
save space, the actual rotation is smooth as silk.&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="Rotating spheric grid animation" class="img-responsive" src="http://hiphish.github.io/grid-framework/news/2015/11/27/spheric-rendering/images/rotating-grid.gif"/&gt;
&lt;/div&gt;
&lt;p&gt;There is still backend work to be done before it can go live, but things are
looking good so far. I hope I can release it still before the end of the year.&lt;/p&gt;
&lt;p&gt;Also, fun fact: the perspective in the image makes the direction of the axis of
rotation ambiguous. You cannot tell whether the north pole or the south pole is
closer to the camera. If you focus on it you can make your brain change the
rotation on the fly, and if you want to get really trippy you can make your
brain see the grid rotate one way and the axis-arrows the other way.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HiPhish</dc:creator><pubDate>Fri, 27 Nov 2015 00:00:00 +0100</pubDate><guid>tag:hiphish.github.io,2015-11-27:grid-framework/news/2015/11/27/spheric-rendering/</guid><category>spheric</category></item><item><title>Shearing</title><link>http://hiphish.github.io/grid-framework/news/2014/08/24/shearing/</link><description>&lt;p&gt;As I mentioned last time the upcoming release will be a maintenance release
with some much-needed cleanup. While I'm still waiting for approval I have been
working on a new feature for rectangular grids that I had wanted to do for
quite a while now, but couldn't until the cleanup: I'm talking about shearing.&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="Screenshot of sheared grid" class="img-responsive" src="http://hiphish.github.io/grid-framework/news/2014/08/24/shearing/images/shearing.png"/&gt;
&lt;/div&gt;
&lt;p&gt;This is an un-rotated rectangular grid with skewed axes to create the popular
2:1 isometric look. This is quite powerful, because it allows for isometric 2D
graphics to be used with Grid Framework. Getting an isometric look in a 3D game
is very simple, you just rotate the camera until it looks right. However, in a
2D game the camera has to be perpendicular to the image plane and objects are
just drawn as if they were at an angle, so rotation is out of question.&lt;/p&gt;
&lt;p&gt;Shearing is fully implemented, I just need to write the documentation for it.
It works with arbitrary numbers and for all axes along any other axis, so you
can shear your grids any way you want. It will be a feature for the 1.5 update
once the upcoming 1.4.2 release gets approved.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HiPhish</dc:creator><pubDate>Sun, 24 Aug 2014 00:00:00 +0200</pubDate><guid>tag:hiphish.github.io,2014-08-24:grid-framework/news/2014/08/24/shearing/</guid><category>old-blog</category></item><item><title>What's up next?</title><link>http://hiphish.github.io/grid-framework/news/2013/07/19/whats-up-next/</link><description>&lt;p&gt;Hello everyone, I decided to do a status update so you know what's going on and
coming next.&lt;/p&gt;
&lt;div class="section" id="two-new-examples"&gt;
&lt;h2&gt;Two new examples&lt;/h2&gt;
&lt;p&gt;The first example is something I wanted to do for quite a while, it generates a
terrain mesh like the terrain in games like SimCity from a plain text file. You
provide the numbers for the height of vertices and the mesh gets created. On
top of that you can click a vertex to raise it and right-click to lower. All
the vertices will be placed along the vertices of the grid, so the level
designer doesn't have to wory about the layout of the scene.&lt;/p&gt;
&lt;p&gt;The other example is a rotary phone dial using polar grids, it's based on a
suggestion by a customer (I always appreciate input, don't be shy ^^). You have
a rotary dial, you click it and then it rotates like a real dial, depending on
which number you clicked. It may no look very impressive on its own, but the
template could be used for all kinds of cool UI displays and menus. It works by
checking which sector of the grid was clicked and then multiplying that with
the angle of the grid and then applying the rotation over time.
Both examples are already done and will definitely be part of the next update.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="new-hexagonal-coordinate-systems"&gt;
&lt;h2&gt;New hexagonal coordinate systems&lt;/h2&gt;
&lt;p&gt;This is the main feature of the upcoming update. Up until now the only
coordinate system hex grids had was the herringbone pattern. It's easy to
understand, but when writing for it you often have to differentiate between odd
and even X-coordinate, which is... stupid. The new coordinate systems don't
have that problem, but they are harder to understand, so pick your poison ;)&lt;/p&gt;
&lt;p&gt;The first coordinate system is "rhombic", meaning the X-axis is rotated 30°
upwards. This removes the need for the even/odd cases, but now moving
south-west is actually moving west. The second coordinate system is "cubic", it
uses three axes in two dimensions. To understand it remember the game Qbert,
the game world is in 3D with cubes, but the actual graphics are in 2D and the
cubes are actually hexagons. Finally, we have barycentric coordinates for the
more mathematically inclined.&lt;/p&gt;
&lt;p&gt;I really want this feature to be done before going after playmaker support. I
know you guys want Playmaker and I keep telling you "later", but this is more
urgent. The good news is that these coordiante systems turned out to be much
less painful to implement than I originally expected. I still need to give
everything the final polish and make sure the systems are not only
mathematically correct, but also make sense to a human being, so I'm about 90%
done.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="new-documentation-with-doxygen"&gt;
&lt;h2&gt;New documentation with doxygen&lt;/h2&gt;
&lt;p&gt;Up until now I have been writing the documentation in Pages and exporting it as
PDF. It was an OK workflow and the results looked reasonably well, but as Grid
Framework's API grew it became more and more of a pain to write the actual
documentation with all the cross-references and unified layout and styles. I
have now reached the point where it would be just madness to continue, so I
decided to switch to Doxygen. When you use Doxygen you comment your source code
in a specific manner, then Doxygen parses it and uses your comments to document
all the methods for a human to read.&lt;/p&gt;
&lt;p&gt;The transition phase is ugly, I need to copy-paste or rewrite all my
documentation, but once it's done any future updates will be much easier. This
also means you will get documentation in both HTML and PDF format from now on.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="vertex-matrix-gets-the-axe"&gt;
&lt;h2&gt;Vertex matrix gets the axe&lt;/h2&gt;
&lt;p&gt;Finally, some not-so-good news. I have been thinking about this for a while,
and the vertex matrix methods were never really good. The idea was to give you
a quick and simple way to store some vertices of a grid in an array and be able
to read them, but the way I did it is way too specific. It will only be useful
in a handful of cases. This leaves me with two options: either expand on it,
writing many variants of the method and on top of that doing the same thing for
faces, boxes and edges, or just cut it out.&lt;/p&gt;
&lt;p&gt;I decided to cut it out, because there is no point in dragging all that code
along, when most people will never use it and some will only use a fraction of
it. It would be much easier and better if the users themselves wrote their own
methods, it's less than ten lines of code anyway and you get full control over
what you want. You don't have to drag along an array that's four times larger
than you need. When looking at the examples I wrote, not even I used the vertex
matrix methods once, because it was easier and cleaner just to roll it from
scratch.&lt;/p&gt;
&lt;p&gt;Naturally this raises another concern, what about the people who were using
this method? I can't just rip it out and tell them to write it themselves. This
is where extension methods come into play: After I removed the methods I put
them back into and extension method in a separate file, which I ZIPed. If you
need the vertex matrix methods back just unzip it and you won't notice any
difference. Of course if enough people actually want the vertex matrix to stay
in place I'll put it back, but if no one objects this will be the way to go.&lt;/p&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HiPhish</dc:creator><pubDate>Fri, 19 Jul 2013 00:00:00 +0200</pubDate><guid>tag:hiphish.github.io,2013-07-19:grid-framework/news/2013/07/19/whats-up-next/</guid><category>old-blog</category><category>API-change</category></item><item><title>Feature freeze for polar grids</title><link>http://hiphish.github.io/grid-framework/news/2013/06/09/feature-freeze-polar/</link><description>&lt;p&gt;Here is a quick update: I have reached feature freeze for polar grids, meaning
I'm done with all the features. Now I need some last polish and I must prepare
new images for the Asset Store, then it's all good to go. So, what took me so
long? Well, designing and writing code is one thing, then you have to put it to
use This often reveals weak points, some things might seems counter-intuitive,
or some things are more complicated to use than others.&lt;/p&gt;
&lt;p&gt;One example would be making an object rotate as it moves through the grid so
it's always facing outwards. Sure, you can do it using the existing API to
convert through coordiante systems, extract the angle of the object relative to
the grid's Z-axis and then use Unity's built in math functions to create the
quaternion by rotating x degrees around the grid's Z-axis. That doesn't sound
pleasant at all. That's why now you can just call the World2Rotation method to
get the quaternion directly, then you can do whatever you want with it.&lt;/p&gt;
&lt;p&gt;This delayed the release a bit but such small additions can make a big
difference in the end. Another thing worth noting is that this release has been
written in Unity 4 and as such it will list Unity 4 as the required version in
the Asset Store. Unity 4 has been out for half a year now, but even if you
still want to stick with Unity 3 you shouldn't have any problems as I didn't
use any Unity 4 exclusive API.&lt;/p&gt;
&lt;p&gt;Well, that's it for now, thanks for reading.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HiPhish</dc:creator><pubDate>Sun, 09 Jun 2013 00:00:00 +0200</pubDate><guid>tag:hiphish.github.io,2013-06-09:grid-framework/news/2013/06/09/feature-freeze-polar/</guid><category>old-blog</category></item><item><title>Polar grid drawing refined</title><link>http://hiphish.github.io/grid-framework/news/2013/05/26/polar-drawing/</link><description>&lt;p&gt;Hello again&lt;/p&gt;
&lt;p&gt;Last time I showed a preview of polar grids it was a full cycle starting from
the origin containing all layers up to the edge. During runtime if only part of
the grid is visible to the player rendering the whole thing can be a waste of
resources, that's why you have the option of specifying a specific rendering
range.&lt;/p&gt;
&lt;p&gt;I was trying out several approaches of interpreting the rectangular range, but
in the end I went for a polar approach. What does this mean? You have two
Vector3 values, one called renderFrom, the other called renderTo. The
x-coordinate tells what radius to start and end at, the y-coordinate gives us
the starting and ending angle and the z-coordinate gives us the starting and
ending layer. Here is an example of what if can look like:&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="some image" class="img-responsive" src="http://hiphish.github.io/grid-framework/news/2013/05/26/polar-drawing/images/polar-refined.png"/&gt;
&lt;/div&gt;
&lt;p&gt;The only limitations are that the starting radius cannot be less than 0 and
starting values cannot be larger than ending values (and vice-versa). The only
exception is the angle, this is is necessary in order to  be able to draw a
sector from, let's say 300° to 15° (which can be seen as from 300° to 375°).&lt;/p&gt;
&lt;p&gt;This has been the biggest roadblock so far, now I need to do some proper
testing and final polish, write the new documentation and I can submit the
update to Unity. Supporting a new type of grid is a substantial effort and,
since everything is interconnected, it usually requires going through the code
for the other grids as well. Sometimes parts that seemed general enough might
need to be overridden and other parts that seemed very specific become more
general and need to be moved up the hierarchy. Considering this and the updates
since the release of version 12.0 I believe raising the price to from 20$ to
25$ is appropriate.&lt;/p&gt;
&lt;p&gt;Of course, as usual, if you already bought Grid Framework all updates are free
for you. If you intend to buy Grid Framework, now is the chance to still get it
for the lower price. You don't need to rush and get it immediately though, I'll
post an at least one more update before I submit version 1.3.0.&lt;/p&gt;
&lt;p&gt;As always, thank you for your support&lt;/p&gt;
&lt;p&gt;HiPhish&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HiPhish</dc:creator><pubDate>Sun, 26 May 2013 00:00:00 +0200</pubDate><guid>tag:hiphish.github.io,2013-05-26:grid-framework/news/2013/05/26/polar-drawing/</guid><category>old-blog</category></item><item><title>A first look at polar grids</title><link>http://hiphish.github.io/grid-framework/news/2013/05/10/first-look-polar/</link><description>&lt;p&gt;I've been working on the next type of grid: polar grids. The &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Polar_coordinates"&gt;polar
grid&lt;/a&gt; is based on polar
coordinates, meaning instead of identifying a point's position using X and Y
coordinates we use a radius and an angle. The radius tells us how far from the
origin the point is and the angle tells us the direction. This screenshot shows
the new polar grid in Unity&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="some image" class="img-responsive" src="http://hiphish.github.io/grid-framework/news/2013/05/10/first-look-polar/images/polar.png"/&gt;
&lt;/div&gt;
&lt;p&gt;A polar grid is defined by three values: radius, sectors and depth. Radius
refers to how far apart the red circles in the picture are, sectors is how many
sectors you have and depth is how far apart each two layers of a polar grid
are. Since we have a third dimension the mathematically correct term would be a
"&lt;a class="reference external" href="http://en.wikipedia.org/wiki/Cylindrical_coordinate_system"&gt;cylindrical
grid&lt;/a&gt;", but I'll
call it polar just for the sake of simplicity. If you have cylindrical
coordinates just ignore the third component and you get polar coordinates.
You'll notice that the angle between sectors does not define the grid, because
the sectors have to cover the grid completely; you can't have the last sector
be only a third of the other sectors. I'll see if I can still make the angle
adjustable via an accessor.&lt;/p&gt;
&lt;p&gt;Polar grids have a few unique quirks that differentiate them from rectangular
and hex grids. First of all we now have circles instead of straight lines, but
we can't draw actual circles. My solution is to add a "smoothing" option;
without smoothing the red lines inside the sectors will be all straight and the
grid will look like a spider's web, but each increase in smoothing breaks up
the line into more segments, coming closer to a round shape. Of course
increasing the smoothing means that there will be more points to calculate, but
fortunately a single-digit number is already enough to get a smooth look. Also,
the more sectors you have, the less smoothing you need.&lt;/p&gt;
&lt;p&gt;A more fundamental issue rather than just a cosmetic concern is the coordinate
systems. Yes, plural. The first one is the regular cylindrical coordinate
system where radius, angle and height are given as absolute from the origin
with respect to world dimensions. This means, no matter what you set your
grid's radius, sectors or depth to, a given point will always have the same
coordinates. The other one is a grid coordinate system where each component
represents the relative position inside the grid with respect to radius, angle
(calculated from sectors) and depth. Changing the grid also changes the
coordinates of a given point.&lt;/p&gt;
&lt;p&gt;You can convert between both coordinate systems and world space on the fly and
neither system is really "better" than the other. It would be just wrong to
have a polar grid without polar coordinates and it is what you want to use when
moving objects in the world. On the other hand, it you want to think in "grid
space", it's easier to think in terms of fields, like a board game, so grid
coordiantes appear more intuitive.&lt;/p&gt;
&lt;p&gt;At this point all the math is done and the hardest to implement methods
(drawing, coordinate transformation and finding nearest vertex/face/box in all
three coordinate systems) have been written. The next parts should be easier to
implement, but I'm not exactly sure how to design them (what exactly does
"aligning" in a polar grid even mean?). I'll keep you updated once I have more
to show.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HiPhish</dc:creator><pubDate>Fri, 10 May 2013 00:00:00 +0200</pubDate><guid>tag:hiphish.github.io,2013-05-10:grid-framework/news/2013/05/10/first-look-polar/</guid><category>old-blog</category></item><item><title>How about herring for lunch?</title><link>http://hiphish.github.io/grid-framework/news/2012/11/27/herring-for-lunch/</link><description>&lt;p&gt;Another progress update: WorldToGrid and GridToWorld are now implemented. For
those who don't know, those two functions convert a point's coordinates from
world space to grid space, the coordinate system used to locate points relative
to the grid's properties, and back. For rectangular grids it's a fairly simple
idea, the grid can be represented as a standard Cartesian coordinate system.
With hex grids that won't do it, you simply cannot force a hex grid into a
cartesian coordinate system, you need to find something else. Fortunately there
are several topologically identical possibilties whith easier, more intuitive
coordinate systems. For the first release I have decided to use the herringbone
pattern:&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="some image" class="img-responsive" src="http://hiphish.github.io/grid-framework/news/2012/11/27/herring-for-lunch/images/herring.png"/&gt;
&lt;/div&gt;
&lt;p&gt;The vertices of this pattern are the faces of the hex grid. This means the
central face has coordinates (0, 0, Z) and the face north-east of it has the
coordinates (1, 0, Z). This way each single point of the hex grid can be
canonically identified by its coordinates. "Canonically" means that no two
points have the same coordinates and no two coordinates represent the same
point. As a side effect this gives me an all new grid to work with, although
the herringbone grid will have to wait until later before it gets the proper
treatment.&lt;/p&gt;
&lt;p&gt;This brings me almost concludes the hex grid development. The only things left
now are the vertex matrix methods, testing and fixing everything to make sure
it's reliable and then writing the documentation.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HiPhish</dc:creator><pubDate>Tue, 27 Nov 2012 00:00:00 +0100</pubDate><guid>tag:hiphish.github.io,2012-11-27:grid-framework/news/2012/11/27/herring-for-lunch/</guid><category>old-blog</category></item><item><title>Trying to fit a square peg into a hex hole</title><link>http://hiphish.github.io/grid-framework/news/2012/11/22/square-peg-in-round-hole/</link><description>&lt;p&gt;The align feature has been giving me quite some headache lately. For small
objects it's easy, just fit them inside the nearest hex. It gets more
interesting once your object spans over more than one hex. Here is a screenshot
from the game "Age of Wonders" for PC (I upscaled the image manually, AoW has a
very low resolution)&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt='Screenshot from "Age of Wonders"' class="img-responsive" src="http://hiphish.github.io/grid-framework/news/2012/11/22/square-peg-in-round-hole/images/AoW.png"/&gt;
&lt;/div&gt;
&lt;p&gt;As you can see the city goes over two hexes and no matter which of the two I
click, I always select the city. I tried many ways of calculating a resonable
way how to fit such an object into a hex grid, but no matter what I tried, it
was bloated, had many cases and, worst of all, didn't really make any sense.
The way Unity is designed is to work with rectangular objects which might be
rotated. In a hex grid system everything is rotated, but only from our point of
view, in terms of game logic everything is the normal way. This is what is
causing problems, I'm trying to force one viewpoint into a different context.&lt;/p&gt;
&lt;p&gt;So, what's the solution? I decided to go for the easiest and most intuitive
approach: each object will be placed into the centre of its nearest hex. What
about objects that need to go over two fields? In that case the user would have
to set the pivot point manually, either in the 3D modelling aplication or in
Unity by parenting the object to another object and placing them relative to
each other so the pivot object is where you want the pivot point to be. In
fact, this is exactly how the Age of Wonders editor is doing it.&lt;/p&gt;
&lt;p&gt;You'll get a better idea of what I mean when you see it in action. In this
video I'm assembling the structure directly inside the editor. Note that only
the parent spheres have Rigidbodies, but all spheres have colliders and the
script. Unity is designed in such a way that if an object has no rigidbody
calling "rigidbody" will return the RB of its parent. Thus it's always as if I
clicked the parent sphere when I click any sphere of a structure.&lt;/p&gt;
&lt;div class="youtube youtube-16x9"&gt;&lt;iframe allowfullscreen="" frameborder="0" seamless="" src="https://www.youtube.com/embed/JxnZxlfhu9g"&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;p&gt;I think this is a good solution. Unless I somehow come up with a better way to
do aligning this is what I'm going to stick with.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HiPhish</dc:creator><pubDate>Thu, 22 Nov 2012 00:00:00 +0100</pubDate><guid>tag:hiphish.github.io,2012-11-22:grid-framework/news/2012/11/22/square-peg-in-round-hole/</guid><category>old-blog</category></item><item><title>Hex Grids love Vectrosity</title><link>http://hiphish.github.io/grid-framework/news/2012/11/13/hex-grids-love-vectrosity/</link><description>&lt;p&gt;Good news at last, I just finished the finding functions for vertices, both in
grid space and in world space. Here is a screenshot where the yellow gizmo
indicates the vertex closest to the grey sphere.&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="some image" class="img-responsive" src="http://hiphish.github.io/grid-framework/news/2012/11/13/hex-grids-love-vectrosity/images/hex-lovex-vectrosity.png"/&gt;
&lt;/div&gt;
&lt;p&gt;This may not seem like much, but being able to find faces, boxes and vertices
is essential because the other functions rely on them. That's it for now, more
updates to come soon.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HiPhish</dc:creator><pubDate>Tue, 13 Nov 2012 00:00:00 +0100</pubDate><guid>tag:hiphish.github.io,2012-11-13:grid-framework/news/2012/11/13/hex-grids-love-vectrosity/</guid><category>old-blog</category><category>extension</category></item><item><title>Vertex progress</title><link>http://hiphish.github.io/grid-framework/news/2012/11/12/vertex-progress/</link><description>&lt;p&gt;Good news at last, I just finished the finding functions for vertices, both in
grid space and in world space. Here is a screenshot where the yellow gizmo
indicates the vertex closest to the grey sphere.&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="some image" class="img-responsive" src="http://hiphish.github.io/grid-framework/news/2012/11/12/vertex-progress/images/vertex-progress.png"/&gt;
&lt;/div&gt;
&lt;p&gt;This may not seem like much, but being able to find faces, boxes and vertices
is essential because the other functions rely on them. That's it for now, more
updates to come soon.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HiPhish</dc:creator><pubDate>Mon, 12 Nov 2012 00:00:00 +0100</pubDate><guid>tag:hiphish.github.io,2012-11-12:grid-framework/news/2012/11/12/vertex-progress/</guid><category>old-blog</category></item><item><title>Hex grid progress so far</title><link>http://hiphish.github.io/grid-framework/news/2012/09/02/hex-grid-progress/</link><description>&lt;p&gt;Here's a quick status update:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;em&gt;Drawing:&lt;/em&gt; This works perfectly now, the hexes are drawn properly as
described in the post before, and now i have added lines that connect the
different layers of the grid.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Rendering:&lt;/em&gt; Like drawing alsmost finished, except one minor issue. In the
rectangular grids you can specify a width for the rendered line and, since
the line is drawn in 2D, I had to calculate the directions in which to expand
the lines. There were only three possible directions and the lines were
sorted by X, Y and Z, so it was enough to calculate each of the three
directions only once. With hex grids one set of lines is zig-zagged, so I
need to calculate four directions total. I need to find a nice way to
separate the the two differently slanted lines. I don't want to calculate the
direction for every line as that would be a waste of ressources.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Find nearest face &amp;amp; Get face coordinates:&lt;/em&gt; done, although only for the
default coordinate system.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Find nearest box &amp;amp; Get box coordinates:&lt;/em&gt; done, just like above&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This leaves the following functions:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;em&gt;Find nearest vertex &amp;amp; Get vertex coordinates:&lt;/em&gt; The challenge here lies in
finding a nice coordinate system, and by nice I mean one that's intuitive to
understand, easy to implement and easy to maintain&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Build vertex matrix &amp;amp; read vertex matrix:&lt;/em&gt; Getting the vertices is already
done, the challenge again lies in finding a good coordinate system.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Align &amp;amp; Scale transform:&lt;/em&gt; shouldn't pose any problems&lt;/li&gt;
&lt;li&gt;&lt;em&gt;World to Grid &amp;amp; Grid to World:&lt;/em&gt; you guessed it, deciding on a coodinate
system&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Get Vectrosity Points:&lt;/em&gt; This will take the same points as used by rendering
and drawing, but the array has to be processed first to fit Vectrosity's
requirements&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So, all in all it looks pretty good. Unfortunately progress has been dragged
down by my studies, I'm writing exams soon, so I can't afford to work on Grid
Framework full time. The plan is to finish all the needed functionalityl for
the first release. After that additional coordinate systems will be added and
after that I'll add more drawing shapes like triangular and circular hex grids.
That will conclude the hex grid chapter of Grid Framework.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HiPhish</dc:creator><pubDate>Sun, 02 Sep 2012 00:00:00 +0200</pubDate><guid>tag:hiphish.github.io,2012-09-02:grid-framework/news/2012/09/02/hex-grid-progress/</guid><category>old-blog</category></item><item><title>Hex grid drawing - finally!</title><link>http://hiphish.github.io/grid-framework/news/2012/08/30/hex-drawing/</link><description>&lt;p&gt;I have finished the drawing part for hex grids. As I mentioned before, there
are many ways to draw hex grids and I want to cover as many of them as
possible. Let's count all the possibilities that work now.&lt;/p&gt;
&lt;p&gt;There are three plains to draw on, the XY-, XZ- and YZ-plain. In each case you
have the choice of having pointy sides or flat sides, those are two
possibilities. Every second line is offset upwards, so you can either draw
those offsets or keep the grid compact, so two more choices. Each grid can
begin with an offset colum or not (two more) and end with an offset column or
not (again, two more). That's a total of 3 x 2 x 2 x 4 = 48 possibilities! On
top of that no line should be calculated more than once, or else it would be
drawn twice. That may seem trivial, but if your lines are semi-transparent the
difference between lines drawn once and twice can be seen.&lt;/p&gt;
&lt;p&gt;Needless to say I don't want to write and maintain 48 similar algorithms,
everything has to be handled automatically by one single function. Eventually I
got it, it works with any of those possibilities. I've prepared four variations
of the same grid to give you an idea. The upper ones are the pointy sides, the
lower ones are the flat sides. The left ones are fully drawn, the right ones
are compact.&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="some image" class="img-responsive" src="http://hiphish.github.io/grid-framework/news/2012/08/30/hex-drawing/images/hex-drawing.png"/&gt;
&lt;/div&gt;
&lt;p&gt;There are also other ways to draw a hex grid, as a rhomb, a triangle or a big
hexagon made from smaller hexagons. I will do them after I have the scripting
functionality done, drawing is independent from the other calculations.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HiPhish</dc:creator><pubDate>Thu, 30 Aug 2012 00:00:00 +0200</pubDate><guid>tag:hiphish.github.io,2012-08-30:grid-framework/news/2012/08/30/hex-drawing/</guid><category>old-blog</category></item><item><title>The current roadblock</title><link>http://hiphish.github.io/grid-framework/news/2012/08/23/current-roadblock/</link><description>&lt;p&gt;It has been over a week since my last post, so I might as well explain what's
going on. As I finished rendering I had tightened up all loose ends that were
left, I consider Grid Framework to be complete for rectangular grids. You can
perform all the common calculations, debug things and visualize the grid
properly, either using simple lines or even Vectrosity. This is just the first
step though. Hex grids are very popular for games for various reasons, so it
makes perfect sense to do them next, right? Well, here is where the problem
starts.&lt;/p&gt;
&lt;p&gt;See, while making Grid Framework there are several challenges I need to face
(let's just ignore things like documentation or presentation for now).
Obviously I need to code the whole thing. I also need to figure out the math
for how to even do these calculations. None of those are really any big
secrets, the math has been there for centuries and the coding part is just
turning verbose instructions into C# code. It's a pretty straight-forward
process, more or less, once you figured out what to do and how to do it. And
that's where the current challenge lies.&lt;/p&gt;
&lt;p&gt;Rectangular grids are relatively simple. Being in 3D and able to rotate and
translate and having individual spacing made them more complicated, but it was
still the same basic formulae, just more expanded. Hex grids are not as easy,
simply because there is more you can do with them. This leaves me with some
really nasty design decision.&lt;/p&gt;
&lt;p&gt;When writing an extension I need to keep in mind that it will be used by lots
of different people who might have different ideas about what a hex grid should
work like. Some might want to fit a grid inside a rectangle, like in battle for
Wesnoth, others might want one big hexagon made of smaller hexagons, like in
Settlers of Catan. I cannot just pick one and tell the others to convert their
game to the other type. This also raises the question of coordinates. A
rectangular grid is just a standard cartesian coordinate system with some
stretching and squeezing. I can even have fractions of a coordinate to give a
precise position. If I fit a hex grid inside a rectangular grid, can I still
have fractions? Do I even want such a feature? What should the coordinates
represent, vertices or faces? What about the pointy side of a hexagon, is it
one unit or just half a unit? Speaking of which, how does everything change if
I want the tops to be pointy instead of the sides? Where should the origin lie?
How many axes should even be there? (don't laugh, once concept uses four
dimensions)&lt;/p&gt;
&lt;p&gt;All of these questions can be answered, that is not the problem. The problem
lies in answering them all in a way that is clean to implement, clean to
maintain and clean for the end user to use. Should I make different hex grid
classes, which would be easier to code, but would mean more code to maintain
and more API for the user? I would like to just start coding and see what
happens, but these questions need to be answered first, or the code will
explode right in my face. I don't know how long it will take, but I'm working
on it.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HiPhish</dc:creator><pubDate>Thu, 23 Aug 2012 00:00:00 +0200</pubDate><guid>tag:hiphish.github.io,2012-08-23:grid-framework/news/2012/08/23/current-roadblock/</guid><category>old-blog</category></item><item><title>A new inspector</title><link>http://hiphish.github.io/grid-framework/news/2012/08/07/new-inspector/</link><description>&lt;p&gt;Well, I wanted to do this sooner or later anyway, so I made a custom editor for
the rectangluar grid. Before this I was using the default inspector panel:&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="some image" class="img-responsive" src="http://hiphish.github.io/grid-framework/news/2012/08/07/new-inspector/images/inspector.png"/&gt;
&lt;/div&gt;
&lt;p&gt;So, why am I doing GUI stuff if I'm supposed to work on the rendering? Well, as
I said I need to clean up the code, which involves looping through two custom
classes of mine, ColorVector3 and BoolVector3. If you used Vector3 you know you
can access values using something like myVector.x, but you can also use an
index instead: myVector[0]&lt;/p&gt;
&lt;p&gt;I wanted to have both in my two classes so I could loop through them in one go
rather than write a special case for each entry and provide an intuitive syntax
for users. The solution was using an indexer, setters and getters. They all
work fine in code, but I cannot get getters and setter to display in the
inspector and manipulating the entries directly could break things. The
solution was writing my own inspector from scratch.&lt;/p&gt;
&lt;p&gt;Aside from now being able to provide a safe and clean way to set colors and
toggle axes the new inspector looks cleaner and the attributes are sorted in a
way that makes more sense, rather than the way the class is built. I'm still
not satisfied with some parts, the axis colours don't have labels and the the
hide axis flags should be on the same line, like the Vector3 field. However, if
I force them on one line or add labels to the coulour flieds the space for the
labels is so large that the controls start overlapping, so it looks even worse
than before.&lt;/p&gt;
&lt;p&gt;Anyway, it does look better now and gives me the code improvements I need for
clean rendering, so all in all it's a success.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HiPhish</dc:creator><pubDate>Tue, 07 Aug 2012 00:00:00 +0200</pubDate><guid>tag:hiphish.github.io,2012-08-07:grid-framework/news/2012/08/07/new-inspector/</guid><category>old-blog</category></item><item><title>Grid rendering progress</title><link>http://hiphish.github.io/grid-framework/news/2012/08/06/grid-rendering-progress/</link><description>&lt;p&gt;Take a look at this:&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="some image" class="img-responsive" src="http://hiphish.github.io/grid-framework/news/2012/08/06/grid-rendering-progress/images/grid-rendering-progress.png"/&gt;
&lt;/div&gt;
&lt;p&gt;What's so special? Look at the upper right corner, gizmos are turned off. This
is a grid rendered at runtime that would be visible in a released game. There
are still some things to care take of first: For one, the grid needs to get
rendered every frame, which is not a big deal when using the GL class, but a
Vectrosity-like approach where a mesh is built only once and then drawn once
until it updates would be pretty neat. Also, the GL class doesn't let you set
the width of lines, I could draw quads instead, but those are only thick if you
look directly at them, otherwise they get thinner until they become invisble
(in other words, they are flat). Lines are always the same, no matter the angle
or distance, which could be exactly what you want or not. Maybe I could include
some way for users to use Vectrosity easily if they have a license? In any
case, I need to finish this first. The code is still very messy, being in large
parts copy-pasted from the drawing code (which was kind of messy itself) and
copy-pasting code is a sure way to have your project explode right in your
face. I'll need to write a method to return a nice list of points that both
drawing and rendering can use.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HiPhish</dc:creator><pubDate>Mon, 06 Aug 2012 00:00:00 +0200</pubDate><guid>tag:hiphish.github.io,2012-08-06:grid-framework/news/2012/08/06/grid-rendering-progress/</guid><category>old-blog</category></item><item><title>State of the game</title><link>http://hiphish.github.io/grid-framework/news/2012/05/14/state-of-the-game/</link><description>&lt;p&gt;It has been over a month since I posted the introductory video and sent my
application to Unity. I never received any confirmation, so I assume it got
lost somewhere along the way...&lt;/p&gt;
&lt;p&gt;Anyway, that doesn't mean I have been sitting here for over a month staring at
the screen and refreshing my mail. I started working on this project because I
needed a simple solution for one certain problem, that's how I started working
and over time more and more ideas came to my mind. It was clear that I would
need a complete rewrite sooner or later, so I decided to release a simple
version first and then start the rewrite instead of throwing everything up to
that point out the window.&lt;/p&gt;
&lt;p&gt;When I sent my submission to Unity I was done with the old concept and started
working on the new, more robust concept that would allow for far more features
to be implemented cleanly. This meant switching to C# (since some things just
aren't possible in UnityScript) and diving deeper into the documentation than
ever before. I like the results. I set myself a few goals and so far I have
achieved most of them. This includes:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;grids as components instead of plain classes&lt;/li&gt;
&lt;li&gt;fully support 3D grids and rotation&lt;/li&gt;
&lt;li&gt;functions to find vertices, faces and boxes with just one line of code&lt;/li&gt;
&lt;li&gt;a nice panel for aligning and scaling instead of that dirty workaround&lt;/li&gt;
&lt;li&gt;switch between grid coordinates and world coordinates (and vice-versa) with just one line of code&lt;/li&gt;
&lt;li&gt;every kind of grid (quare grid, hex grid, triangular grid) inherits from one common Grid class&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Most work has been done under the hood to keep the code clean. It's easy to
insert a new feature into clean code where I can leverage already existing
methods instead of having to write the same thing several times (copy-pasting
chunks of code is an awful idea!).  The one thing that still needs a good look
are the methods related to the vertex matrix, it's one of those things that are
easy to break if you aren't careful.&lt;/p&gt;
&lt;p&gt;That said, once it's done the (hopefully now) first release would be ready to
ship. I'd also have to rewrite the entire documentation and draw new logos for
the Asset Store (in a way I'm glad my first submission got lost, those
"drawings" were just aweful)&lt;/p&gt;
&lt;p&gt;The fist release would only cover rectangular grids with hex grids added next,
then finally triangular grids. I haven't started implementing them, but I have
already done the math and I know how to do it, I just need to finish this
first. The one last thing I can think of is grid pathfinding, but I won't even
waste a thought on that until I get the other stuff done.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HiPhish</dc:creator><pubDate>Mon, 14 May 2012 00:00:00 +0200</pubDate><guid>tag:hiphish.github.io,2012-05-14:grid-framework/news/2012/05/14/state-of-the-game/</guid><category>old-blog</category></item></channel></rss>