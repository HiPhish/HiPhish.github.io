<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>HiPhish's Workshop</title><link href="http://hiphish.github.io/" rel="alternate"></link><link href="http://192.168.0.190:8000/blog/atom.xml" rel="self"></link><id>http://hiphish.github.io/</id><updated>2016-07-06T00:00:00+02:00</updated><entry><title>Introducing IPS-Tools</title><link href="http://hiphish.github.io/blog/2016/07/06/intro-ips-tools/" rel="alternate"></link><published>2016-07-06T00:00:00+02:00</published><author><name>HiPhish</name></author><id>tag:hiphish.github.io,2016-07-06:blog/2016/07/06/intro-ips-tools/</id><summary type="html">&lt;p&gt;I found myself needing a program to apply binary patches in the IPS file format
and I was really disappointed  that there are no proper  Unix programs for that
purpose available.  So I set out to make my own,  but instead of just  applying
patches it would be a complete suite of tools to handle all IPS-related tasks.&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://gitlab.com/HiPhish/IPS-Tools"&gt;IPS-Tools&lt;/a&gt; is the result, it consists of three standalone CLI programs, one CLI
program that acts as an entry point to the suite, and a C library for inclusion
in other applications. There are three programs because I have identified three
problem domains: applying a patch, generating a patch and examining a patch.&lt;/p&gt;
&lt;p&gt;The tools are all written in C99 using only the standard library, they are tiny
and  should  run  on  pretty  much  anything.  Great  for  embedding  in  other
applications.  In fact,  I have a  GUI frontend that  uses the library  to give
users a drag &amp;amp; drop interface, but it still needs some more polish before I can
release it.&lt;/p&gt;
&lt;p&gt;I also took the opportunity  to write a complete specification  of the IPS file
format, because all I was able to find have been bits and pieces everywhere and
only closed-source programs, so I had to piece things together. IPS is a fairly
simple format,  but it  has some  hairy corners  because over  time people have
added  extensions  to it  (compressed records  and truncation).  With IPS-tools
there is a complete  file specification and  a reference implementation  freely
available to the public.&lt;/p&gt;
</summary></entry><entry><title>Highlighting NSImageView the right way</title><link href="http://hiphish.github.io/blog/2016/06/25/highlighting-nsimageview/" rel="alternate"></link><published>2016-06-25T00:00:00+02:00</published><author><name>HiPhish</name></author><id>tag:hiphish.github.io,2016-06-25:blog/2016/06/25/highlighting-nsimageview/</id><summary type="html">&lt;p&gt;Recently  I have  been working on  a small Cocoa  app and one  of the  things I
needed to do was highlight an  &lt;code&gt;NSImageView&lt;/code&gt; when the user is hovering above it
while dragging a file.  You would think  that it's a very simple task,  and you
would be right, but judging by some of the things on the internet it looks like
an unsolved problem.&lt;/p&gt;
&lt;p&gt;The difficult part about Mac development is not Objective-C, if you know C then
you can learn  Objective-C in a  few days.  The hard part is Cocoa.  Cocoa is a
very old framework,  older than .NET, Java and macOS.  A framework  this old is
guaranteed to have grown a lot  over the years and finding what you are looking
for can  be a  daunting task.  Even Apple's  own documentation  is filled  with
deprecated API calls or downright bad practice.&lt;/p&gt;
&lt;div class="section" id="the-wrong-way"&gt;
&lt;h2&gt;The wrong way&lt;/h2&gt;
&lt;p&gt;Here is how Apple's own documentation highlights an &lt;code&gt;NSImageView&lt;/code&gt; instance. The
code is from the official &lt;a class="reference external" href="https://developer.apple.com/library/mac/samplecode/CocoaDragAndDrop/Introduction/Intro.html"&gt;CocoaDragAndDrop&lt;/a&gt; example.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;-(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;drawRect:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NSRect&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;rect&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="cm"&gt;/*------------------------------------------------------&lt;/span&gt;
&lt;span class="cm"&gt;        draw method is overridden to do drop highlighing&lt;/span&gt;
&lt;span class="cm"&gt;    --------------------------------------------------------*/&lt;/span&gt;
    &lt;span class="c1"&gt;//do the usual draw operation to display the image&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;super&lt;/span&gt; &lt;span class="nl"&gt;drawRect&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;rect&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;highlight&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;//highlight by overlaying a gray border&lt;/span&gt;
        &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;NSColor&lt;/span&gt; &lt;span class="n"&gt;grayColor&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;set&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;NSBezierPath&lt;/span&gt; &lt;span class="nl"&gt;setDefaultLineWidth&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;NSBezierPath&lt;/span&gt; &lt;span class="nl"&gt;strokeRect&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;rect&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;There are other  implementations on the internet,  but those can be excused for
not being official. They all have the same fundamental problem anyway,  so I'll
just use this one for illustration.&lt;/p&gt;
&lt;p&gt;The implementation  looks simple  enough and works,  but only  as long  as your
&lt;code&gt;NSImageView&lt;/code&gt; instance satisfies the assumptions made here.  We assume that our
view object will always have  the outline of a rectangle and we assume that the
chosen colour  will always  be adequate.  In my  case the first  assumption was
already broken from the start because I was using the &lt;em&gt;Bezel&lt;/em&gt; style for my view
objects, a style that is part of Cocoa itself. There is also no telling when in
the future Apple might change the default colours, making your choice of colour
inadequate. And that's not even going into portability if you want to use
GNUStep to port your app to other operating systems.&lt;/p&gt;
&lt;p&gt;What we want is an abstraction.  Abstractions provide us with a clean interface
that can remain stable while  the underlying implementation  can change wildly.
Cocoa has abstractions everywhere, such as using &lt;code&gt;NSURL&lt;/code&gt; for file paths instead
of C  strings  or even &lt;code&gt;NSString&lt;/code&gt;.  Doing things  your own  way should  only be
reserved for when  you actually have control over the underlying code.  So if I
were  to  draw my  own  shapes  for an  &lt;code&gt;NSView&lt;/code&gt; I  would  also  be comfortable
hard-coding my own highlighting.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-right-way"&gt;
&lt;h2&gt;The right way™&lt;/h2&gt;
&lt;p&gt;As it turns out  Cocoa already provides  us with the  means of abstraction  for
highlighting.  The &lt;code&gt;NSControl&lt;/code&gt; class has the &lt;code&gt;highlighted&lt;/code&gt; property,  which has
the getter &lt;code&gt;isHighlighted&lt;/code&gt;,  so we don't need  a new property.  For drawing the
actual highlight &lt;code&gt;NSView&lt;/code&gt;  provides the method &lt;code&gt;drawFocusRingMask&lt;/code&gt;.  Subclasses
can override  the property  to implement  their own  highlighting  and  luckily
&lt;code&gt;NSImageView&lt;/code&gt; does exacly that.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;drawRect:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NSRect&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;dirtyRect&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;super&lt;/span&gt; &lt;span class="nl"&gt;drawRect&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;dirtyRect&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt; &lt;span class="n"&gt;isHighlighted&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt; &lt;span class="n"&gt;drawFocusRingMask&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now your code is future-proof and will work regardless of the shape you choose.
Well, at least until Apple deprecates this method.&lt;/p&gt;
&lt;/div&gt;
</summary><category term="cocoa"></category></entry><entry><title>Introducing NTFS-Clone</title><link href="http://hiphish.github.io/blog/2016/05/31/into-ntfs-clone/" rel="alternate"></link><published>2016-05-31T00:00:00+02:00</published><author><name>HiPhish</name></author><id>tag:hiphish.github.io,2016-05-31:blog/2016/05/31/into-ntfs-clone/</id><summary type="html">&lt;p&gt;This is  a very  useful project  I had  written quite  a while  ago at work and
recently found collecting dust on my hard drive. It lets you create perfect 1:1
copies of NTFS hard drives on Unix.  The problem with every software I had come
across was  that it would copy the data,  but that wasn't enough,  so we had to
run Windows repair on every single drive.&lt;/p&gt;
&lt;p&gt;What makes NTFS-Clone different from these other software is that the resulting
drive works out of the box.  I achieved this by  following the Unix philosophy:
there are already  command-line tools  that do small parts of the job,  so if I
can take  them and  glue them  together in  the right  way I  can solve the big
problem.&lt;/p&gt;
&lt;p&gt;The result  was rock-stable  and since it  was run on  the command-line we were
able  to automate  the entire process  to clone multiple  drives in  succession
instead of having to babysit them all day. So if you are right now wasting your
time babysitting hard drives,  grab yourself a copy  of &lt;a class="reference external" href="https://gitlab.com/HiPhish/ntfs-clone"&gt;NTFS-Clone&lt;/a&gt; and buy one
of those things where you can plug in several drives and automate your work.&lt;/p&gt;
</summary></entry><entry><title>Neovim has tab-local working directories now</title><link href="http://hiphish.github.io/blog/2016/04/22/neovim-tcd/" rel="alternate"></link><published>2016-04-22T00:00:00+02:00</published><author><name>HiPhish</name></author><id>tag:hiphish.github.io,2016-04-22:blog/2016/04/22/neovim-tcd/</id><summary type="html">&lt;p&gt;My Neovim PR to add tab-local working directories has recently been merged.  In
this post I will explain what it does and why you will love it.&lt;/p&gt;
&lt;div class="section" id="what-are-working-directories-in-vim"&gt;
&lt;h2&gt;What are working directories in Vim?&lt;/h2&gt;
&lt;p&gt;If you know Vim  feel free to skip  this section,  otherwise read on.  Vim is a
terminal application  and the  directory you  launch it  from is  the  &lt;em&gt;working
directory&lt;/em&gt; for  that session.  Even if you use a  GUI version of Vim you have a
working directory which  usually defaults to your home directory.  Any time you
issue an ex-command  or call a shell command  all paths will be  interpreted as
relative to the current working directory.&lt;/p&gt;
&lt;p&gt;Take for  instance the &lt;code&gt;:make&lt;/code&gt; ex-command.  It will call your make program from
the working  directory  and  that program  will usually  search for  a sort  of
makefile  in  that  directory.  Let's  assume you have  a C project  in its own
directory and a makefile in that directory as well.  If Vim's working directory
is the same as the project  directory you  can run &lt;code&gt;:make&lt;/code&gt; and have the project
built immediately.&lt;/p&gt;
&lt;p&gt;This isn't limited  to just &lt;code&gt;:make&lt;/code&gt; alone,  any file navigation also depends on
it. If you have a file browser plugin like  Netrw or NERDTree installed you can
just issue the  ex-command &lt;code&gt;:edit .&lt;/code&gt;  and browse your  project directory.  File
finders like Ctrl-P or Unite would have to go through a huge tree of completely
unrelated directories before they reach the sub-tree of your project. There are
many more examples,  but the point is that  your working directory should match
your project directory.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-motivation-for-tab-local-working-directories"&gt;
&lt;h2&gt;The motivation for tab-local working directories&lt;/h2&gt;
&lt;p&gt;Sometimes you  need to  work  on more  than one project  at a  time.  Take this
website:  There is the website itself, which is one project,  and there are the
Jinja  templates,  which is  another project.  Sometimes I  find a  bug in  the
website and I have to switch to the template project.  I could launch a new Vim
instance, but the instances would be completely isolated. I couldn't transplant
HTML  snippets  from  one  into the  other without  going  through  the  system
clipboard.  Searches issued in  one instance  would not appear in the other,  I
would  have  to  repeat  them  but  that  can  be  really  annoying in  case of
complicated regexes.&lt;/p&gt;
&lt;p&gt;The idea to implement this  feature can from a Vim &lt;a class="reference external" href="http://vimcasts.org/episodes/how-to-use-tabs/"&gt;screencast by Drew Neil&lt;/a&gt;.
In it for some reason  his build of Vim does  have separate working directories
for each tab by default. He seems to think that's a regular feature, but if you
take a look at the comment section you will see that it clearly is not. My best
guess is that it was a bug,  but even after working with the internals of Vim I
cannot imagine how it could have happened.&lt;/p&gt;
&lt;p&gt;There is a Vim plugin called &lt;a class="reference external" href="https://github.com/kana/vim-tabpagecd"&gt;vim-tabpagecd&lt;/a&gt; which makes all tabs have their own
working directory by default.  I was using it for a while, but giving every tab
its own working directory every time seems overkill to me.  So the only natural
course of action was to implement it in Vim directly.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-tcd-ex-command"&gt;
&lt;h2&gt;The &lt;code&gt;:tcd&lt;/code&gt; ex-command&lt;/h2&gt;
&lt;p&gt;I modified Neovim instead of Vim because that's the editor I actually use,  but
if anyone wants  to port this feature  to Vim be my guest.  Anyway, Vim already
has a  similar feature  in the  &lt;code&gt;:lcd&lt;/code&gt; command,  except that  that  command  is
limited to just one window.  I decided the call my command &lt;code&gt;:tcd&lt;/code&gt;;  it's short,
easy to remember and it if you know &lt;code&gt;:lcd&lt;/code&gt; you also know &lt;code&gt;:tcd&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Working directories take precedence over each other with deeper ones overriding
higher ones.  In practice this means that  &lt;code&gt;:tcd&lt;/code&gt; overrides  the global working
directory and that &lt;code&gt;:lcd&lt;/code&gt; overrides the tab-local working directory.&lt;/p&gt;
&lt;p&gt;Bigger changes had to be made to the &lt;code&gt;getcwd()&lt;/code&gt; function. In order to not break
backwards compatibility the function will still work without any arguments,  in
which case  it returns  the effective  working  directory.  If you  supply  one
argument it is  taken to be the number  of the window in the &lt;em&gt;current&lt;/em&gt; tab,  so
you get that window's  effective working directory.  So far this is the same as
in Vim.  However, if you supply a second argument  it is taken to be the number
of a tab. In other words &lt;code&gt;getcwd(3, 2)&lt;/code&gt; returns the effective working directory
of window number  3 in tab number 2.  You can  always use the  number 0 for the
current window  or tab.  Here is where  it gets  interesting:  if you  want the
working directory of a tab regardless  what the working directory of the window
is you supply -1 as  the number of the window.  Even if the window  has its own
local working directory it will be ignored.&lt;/p&gt;
&lt;p&gt;The function &lt;code&gt;haslocaldir()&lt;/code&gt;  works exactly the  same as &lt;code&gt;getcwd()&lt;/code&gt;,  except it
returns whether the working directory is local to that scope.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="even-more-scopes"&gt;
&lt;h2&gt;Even more scopes?&lt;/h2&gt;
&lt;p&gt;A major part  of Neovim's missions  statement is to  bring the codebase  of Vim
into a better state.  The tab-local working directory  feature hasn't been just
bolted onto the existing code, I have properly refactored the inner workings so
that adding a new scope  should take only a few lines of code from now on.  One
could  for example  add a "buffer"  scope that takes  precedence over  tabs and
affects all windows displaying that buffer.  Of course such a scope would raise
new design concerns and it's questionable whether it would even be useful,  but
the important point is that it is now possible.&lt;/p&gt;
&lt;/div&gt;
</summary><category term="neovim"></category></entry><entry><title>Feeds are live now</title><link href="http://hiphish.github.io/blog/2015/11/14/feeds-live-now/" rel="alternate"></link><published>2015-11-14T00:00:00+01:00</published><author><name>HiPhish</name></author><id>tag:hiphish.github.io,2015-11-14:blog/2015/11/14/feeds-live-now/</id><summary type="html">&lt;p&gt;RSS- and Atom feeds are live now. You can subscribe to an entire blog using the
links in the navigator or you can subscribe to a particular category in a blog.
For that navigate to the category using either the navigator or by clicking the
category button of an article.&lt;/p&gt;
</summary><category term="website"></category></entry><entry><title>We are live!</title><link href="http://hiphish.github.io/blog/2015/11/11/we-are-live/" rel="alternate"></link><published>2015-11-11T00:00:00+01:00</published><author><name>HiPhish</name></author><id>tag:hiphish.github.io,2015-11-11:blog/2015/11/11/we-are-live/</id><summary type="html">&lt;p&gt;The Workshop blog is finally up and running, in all its static glory. This
makes the site practically complete, at least as complete as a website can ever
be anyway. It also works great with my &lt;a class="reference external" href="https://gitlab.com/HiPhish/Multiblog-Pelican"&gt;Multiblog&lt;/a&gt; plugin.&lt;/p&gt;
&lt;p&gt;I wanted to be able to have more than one blog on the site. A blog can be a
place for personal ramblings about things no one else care about, but a blog
can also be the primary source of news. Mixing these two seemed like a very bad
idea to me; people might be only interested in one thing, for example Grid
Framework in my case and they don't want their time wasted with other products
and completely unrelated topics.&lt;/p&gt;
&lt;p&gt;So here is my solution: have multiple blogs on the site. A blog consists of
articles and the interface. Blogs can share articles, and the interface is
generated accordingly. The interface is all you see around the main content:
tabs, categories, archives, period archives and so on. I could for example have
one blog for every project and one blog for all projects. People could either
subscribe to the blogs they care about or they subscribe to the aggregate blog.
Anything is possible really.&lt;/p&gt;
&lt;p&gt;As for the blog interface itself, my main goal was in making it easy to
navigate. Originally I had intended for a "temple"-like layout, also called the
&lt;a class="reference external" href="https://en.wikipedia.org/wiki/Holy_Grail_(web_design)"&gt;"Holy Grail"&lt;/a&gt; of web
design because finding a hack-free implementation used to be like searching for
the Holy Grail. Here is a sketch of what it looks like:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
┏━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃          Header         ┃
┣━━━┯━━━━━━━━━━━━━━━━━┯━━━┫
┃   │                 │   ┃
┃ N │     Content     │ A ┃
┃ a │                 │ d ┃
┃ v │                 │ s ┃
┃   │                 │   ┃
┃   │ &amp;lt;-           -&amp;gt; │   ┃
┣━━━┷━━━━━━━━━━━━━━━━━┷━━━┫
┃          Footer         ┃
┗━━━━━━━━━━━━━━━━━━━━━━━━━┛
&lt;/pre&gt;
&lt;p&gt;Thanks to the new flexbox features of CSS this layout is now trivial to
implement and the search is over, check out &lt;a class="reference external" href="http://philipwalton.github.io/solved-by-flexbox/"&gt;Solved by Flexbox&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;However, I decided to opt out of the right column. For one it was making the
content look too crammed in between, and the other reason is that I had no idea
what to put in there. I wouldn't use ads because you need &lt;em&gt;a lot&lt;/em&gt; of clicks to
make them worthwhile and this simply is not one of those blogs where I can put
out content worth reading all the time.&lt;/p&gt;
&lt;p&gt;The left column is used for navigation. This includes period-archives,
categories, tags and authors. I went fancy with an accordion-style tree of
articles, which sadly does not work without JavaScript. That's why the title of
every navigator menu is also a hyperlink to the corresponding archive. Since
archives are nested into archives I also added a navigation breadcrumbs menu
above the content. The finished layout looks like this:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
┏━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃          Header         ┃
┣━━━┯━━━━━━━━━━━━━━━━━━━━━┫
┃   │YYYY/MM/DD/slug      ┃
┃ N ├─────────────────────┃
┃ a │       Content       ┃
┃ v │                     ┃
┃   │                     ┃
┃   │                     ┃
┃   │ &amp;lt;-               -&amp;gt; ┃
┣━━━┷━━━━━━━━━━━━━━━━━━━━━┫
┃          Footer         ┃
┗━━━━━━━━━━━━━━━━━━━━━━━━━┛
&lt;/pre&gt;
&lt;p&gt;The URL of each page is chosen so that moving one directory up in the hierarchy
will move you to the parent archive. For instance, a blog post has the URL
&lt;code&gt;website.com/blog/year/month/day/slug&lt;/code&gt;. Removing the &lt;code&gt;slug&lt;/code&gt; will take you
to the daily archive, removing the day takes you to the monthly archive and
removing the month takes you to the yearly archive. Removing even the year
takes you to the index of the blog. Pretty neat. If changing the URL is too
cumbersome one can also use the breadcrumbs at the top. In my case there are no
daily archives because I will rarely ever write more than one post per day.&lt;/p&gt;
&lt;p&gt;There is no way to subscribe to a blog at the moment, but making Pelican
generate RSS feeds should be trivial. I just haven't looked into yet, I figured
it was better to release now rather than holding back just because of a feature
that does not affect the blogs themselves.&lt;/p&gt;
&lt;p&gt;Some aspects of the blog might seem redundant, like having an &lt;em&gt;authors&lt;/em&gt; archive
when there is only one author on the site. That's me "eating my own dogfood", I
am using a feature because I want to demonstrate its purpose.&lt;/p&gt;
&lt;p&gt;Well, that's it for now, we'll see where this ride will take be from now on.
It's going to be interesting :)&lt;/p&gt;
</summary><category term="website"></category></entry></feed>