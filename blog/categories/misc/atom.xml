<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>HiPhish's Workshop - misc</title><link href="http://hiphish.github.io/" rel="alternate"></link><link href="http://127.0.1.1:8000/blog/categories/misc/atom.xml" rel="self"></link><id>http://hiphish.github.io/</id><updated>2017-07-16T00:00:00+02:00</updated><entry><title>A purely functional fixed timestep loop</title><link href="http://hiphish.github.io/blog/2017/07/16/functional-fixed-timestep-loop/" rel="alternate"></link><published>2017-07-16T00:00:00+02:00</published><updated>2017-07-16T00:00:00+02:00</updated><author><name>HiPhish</name></author><id>tag:hiphish.github.io,2017-07-16:/blog/2017/07/16/functional-fixed-timestep-loop/</id><summary type="html">&lt;p&gt;There is a great article by Glenn Fiedler titled &lt;a class="reference external" href="http://gafferongames.com/game-physics/fix-your-timestep/"&gt;“Fix Your Timestep!”&lt;/a&gt; in
which the author explains various approaches to writing a game loop and
concludes with a loop that provides a fixed time step for simulation. If you
are not familiar with this topic go read the article first …&lt;/p&gt;</summary><content type="html">&lt;p&gt;There is a great article by Glenn Fiedler titled &lt;a class="reference external" href="http://gafferongames.com/game-physics/fix-your-timestep/"&gt;“Fix Your Timestep!”&lt;/a&gt; in
which the author explains various approaches to writing a game loop and
concludes with a loop that provides a fixed time step for simulation. If you
are not familiar with this topic go read the article first and come back later.
The author has written the implementation in C or C++ using a lot of mutation
and looping, so I wanted to give a purely functional approach a shot.&lt;/p&gt;
&lt;p&gt;So why do it the functional way? I like challenging myself and I believe you
need to be able to approach a problem from different angles using different
tools in order to &lt;em&gt;really&lt;/em&gt; understand the problem. When I first read the
article a long time ago I was able to understand &lt;em&gt;what&lt;/em&gt; the code was doing, but
the reason for &lt;em&gt;why&lt;/em&gt; the code was doing it was hard to grasp. What really
helped me understand the method was shifting my perspective from the imperative
mindset to a functional signal-processing mindset.&lt;/p&gt;
&lt;p&gt;The language I am using is &lt;a class="reference external" href="http://www.r7rs.org"&gt;R7RS&lt;/a&gt; Scheme and my implementation is &lt;a class="reference external" href="http://synthcode.com/scheme/chibi/"&gt;Chibi-Scheme&lt;/a&gt;,
although any implementation conforming to R7RS should be able to run the code.&lt;/p&gt;
&lt;div class="section" id="the-fundamental-idea"&gt;
&lt;h2&gt;The fundamental idea&lt;/h2&gt;
&lt;p&gt;The entire application is driven by a loop: the loop measures time and then
based upon that time it simulates and renders the virtual world. The time in
the virtual world needs to sync up with the time of the real world to create
the illusion of looking through a window. However, the programmer must not fall
into the trap of thinking that the time in the simulation needs to match the
time in the real world, only the output has to match.&lt;/p&gt;
&lt;p&gt;What does this mean? It means that the simulation only needs to know how much
virtual time has passed in the simulation so far and by how much virtual time
to advance the simulation. Whether this matches up with the real world or not
does not matter for now.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;simulate&lt;/span&gt; &lt;span class="nv"&gt;t&lt;/span&gt; &lt;span class="nv"&gt;Δt&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This raises the next question: if the simulation is fed the "time" instead of
getting the time itself, where does this "time" come from? The answer is that
there is a function which emits a &lt;code&gt;Δt&lt;/code&gt; signal. This signal is then received by
the &lt;code&gt;simulate&lt;/code&gt; function.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;; `t` is the time that has passed so far in the simulation since it was&lt;/span&gt;
&lt;span class="c1"&gt;;; started, `lag` will be explained later&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;emit-Δt-signal&lt;/span&gt; &lt;span class="nv"&gt;t&lt;/span&gt; &lt;span class="nv"&gt;lag&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So what then is calling the emitter function? The game loop. The game loop
measures real time and based on that decides on how many &lt;code&gt;Δt&lt;/code&gt; signals to emit.
If the loop is running very quickly (high frame rate) it will emit only a few
signals, and if it runs slowly it will emit multiple &lt;code&gt;Δt&lt;/code&gt; signals. The point is
that neither the signal emitter nor the signal receiver need to be concerned
about the state of the clock.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-code"&gt;
&lt;h2&gt;The code&lt;/h2&gt;
&lt;p&gt;All code has to be purely functional, this means no mutation and no shared
state. The only exception is the real-world clock because depending on global
state is the entire point of a clock. To simulate frames taking time I will use
a fake clock which advances time by one second every call.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;;; Returns the "real" time of the physical world. Actually, it just counts up&lt;/span&gt;
&lt;span class="c1"&gt;;;; from zero, but for our purpose this is simply the real-world clock.&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="nv"&gt;real-time&lt;/span&gt;
  &lt;span class="c1"&gt;;; Store the current time as state with initial value zero.&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;time&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda &lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;t&lt;/span&gt; &lt;span class="nv"&gt;time&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;  &lt;span class="c1"&gt;; Store the current time in a temporary variable&lt;/span&gt;
        &lt;span class="c1"&gt;;; Increment the time, but return the time before increment&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;set! &lt;/span&gt;&lt;span class="nv"&gt;time&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="nv"&gt;time&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;jiffies-per-second&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
        &lt;span class="nv"&gt;t&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We will also need some fake &lt;code&gt;simulate&lt;/code&gt; and &lt;code&gt;render&lt;/code&gt; functions:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;; A real simulation function does not take lag, but we want to show it here&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;simulate&lt;/span&gt; &lt;span class="nv"&gt;t&lt;/span&gt; &lt;span class="nv"&gt;Δt&lt;/span&gt; &lt;span class="nv"&gt;lag&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;display &lt;/span&gt;&lt;span class="s"&gt;"Simulating with t="&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;display &lt;/span&gt;&lt;span class="nv"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;display &lt;/span&gt;&lt;span class="s"&gt;", Δt="&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;display &lt;/span&gt;&lt;span class="nv"&gt;Δt&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;display &lt;/span&gt;&lt;span class="s"&gt;", lag="&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;display &lt;/span&gt;&lt;span class="nv"&gt;lag&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;newline&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;render&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;display &lt;/span&gt;&lt;span class="s"&gt;"Rendering...\n"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;These just print something to the standard output. Let's now get to the real
meat: the game loop function. Of course it's not a real loop, it's a recursive
function.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;;; Run the game loop with fixed time step Δt.&lt;/span&gt;
&lt;span class="c1"&gt;;;;&lt;/span&gt;
&lt;span class="c1"&gt;;;; Parameters:&lt;/span&gt;
&lt;span class="c1"&gt;;;;   t         Total simulation time which has passed so far&lt;/span&gt;
&lt;span class="c1"&gt;;;;   Δt        The fixed tick rate&lt;/span&gt;
&lt;span class="c1"&gt;;;;   time      Total real-world time since the first iteration&lt;/span&gt;
&lt;span class="c1"&gt;;;;   lag       How much the simulation is behind real time&lt;/span&gt;
&lt;span class="c1"&gt;;;;   simulate  Callback to execute on every tick&lt;/span&gt;
&lt;span class="c1"&gt;;;;   render    Callback to execute every frame&lt;/span&gt;
&lt;span class="c1"&gt;;;;   quit      Whether to exit the game loop&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;run-game-loop&lt;/span&gt; &lt;span class="nv"&gt;Δt&lt;/span&gt; &lt;span class="nv"&gt;t&lt;/span&gt; &lt;span class="nv"&gt;time&lt;/span&gt; &lt;span class="nv"&gt;lag&lt;/span&gt; &lt;span class="nv"&gt;simulate&lt;/span&gt; &lt;span class="nv"&gt;render&lt;/span&gt; &lt;span class="nv"&gt;quit&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The parameters are in place of what would normally be the state in imperative
programming. &lt;code&gt;t&lt;/code&gt; is the total virtual time passed so far, &lt;code&gt;Δt&lt;/code&gt; is the fixed
time step. &lt;code&gt;lag&lt;/code&gt; is interesting, this is the leftover time that was not
simulated in the previous frame and which will be carried over to the next
frame. &lt;code&gt;simulate&lt;/code&gt; and &lt;code&gt;render&lt;/code&gt; are our callback functions and &lt;code&gt;quit&lt;/code&gt; is a
boolean that tells us whether to exit the loop.&lt;/p&gt;
&lt;p&gt;The first item in &lt;code&gt;run-game-loop&lt;/code&gt; is the definition of the &lt;code&gt;Δt&lt;/code&gt; emitter.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;; Emit a Δt signal for simulation&lt;/span&gt;
&lt;span class="c1"&gt;;;&lt;/span&gt;
&lt;span class="c1"&gt;;; Parameters:&lt;/span&gt;
&lt;span class="c1"&gt;;;  t    Virtual time that has passed so far in the simulation&lt;/span&gt;
&lt;span class="c1"&gt;;;  lag  How much the simulation is behind real time&lt;/span&gt;
&lt;span class="c1"&gt;;;&lt;/span&gt;
&lt;span class="c1"&gt;;; Returns: The time the simulation has been advanced by and the remaining&lt;/span&gt;
&lt;span class="c1"&gt;;; lag.&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;emit-Δt-signal&lt;/span&gt; &lt;span class="nv"&gt;t&lt;/span&gt; &lt;span class="nv"&gt;lag&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;lt; &lt;/span&gt;&lt;span class="nv"&gt;lag&lt;/span&gt; &lt;span class="nv"&gt;Δt&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;values &lt;/span&gt;&lt;span class="nv"&gt;t&lt;/span&gt; &lt;span class="nv"&gt;lag&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;; We cannot fit in any more ticks, return&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;begin&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;simulate&lt;/span&gt; &lt;span class="nv"&gt;t&lt;/span&gt; &lt;span class="nv"&gt;Δt&lt;/span&gt; &lt;span class="nv"&gt;lag&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;emit-Δt-signal&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="nv"&gt;t&lt;/span&gt; &lt;span class="nv"&gt;Δt&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="nv"&gt;lag&lt;/span&gt; &lt;span class="nv"&gt;Δt&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;code&gt;lag&lt;/code&gt; is how much simulation time we have to process. As an example, let's
say our &lt;code&gt;Δt&lt;/code&gt; is 50 milliseconds and a frame takes one second, that means we can
fit in 20 &lt;code&gt;Δt&lt;/code&gt; signals with no leftover lag. On the other hand, if our frame
rate is 60Hz and &lt;code&gt;Δt&lt;/code&gt; 10ms, that means the lag is about 16ms and we can only
fit in one signal.  Furthermore, there are 6ms of lag left which are returned
as the result of the emitter along with the total time simulated.&lt;/p&gt;
&lt;p&gt;The emitter will keep pumping out &lt;code&gt;Δt&lt;/code&gt; signals as long as it can fit &lt;code&gt;Δt&lt;/code&gt;
inside &lt;code&gt;lag&lt;/code&gt;. With each iteration it increases the total time simulated &lt;code&gt;t&lt;/code&gt; by
&lt;code&gt;Δt&lt;/code&gt; and decrease the &lt;code&gt;lag&lt;/code&gt; by &lt;code&gt;Δt&lt;/code&gt;. When it can no longer fit a &lt;code&gt;Δt&lt;/code&gt; inside
the &lt;code&gt;lag&lt;/code&gt; it returns the &lt;code&gt;t&lt;/code&gt; and &lt;code&gt;lag&lt;/code&gt; as return values.&lt;/p&gt;
&lt;p&gt;After this function definition comes the body of the game loop function.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let* &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;new-time&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;real-time&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
       &lt;span class="c1"&gt;;; How long the last frame took to compute&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;frame-time&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="nv"&gt;new-time&lt;/span&gt; &lt;span class="nv"&gt;time&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;let-values&lt;/span&gt; &lt;span class="p"&gt;(((&lt;/span&gt;&lt;span class="nf"&gt;t&lt;/span&gt; &lt;span class="nv"&gt;lag&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;emit-Δt-signal&lt;/span&gt; &lt;span class="nv"&gt;t&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="nv"&gt;lag&lt;/span&gt; &lt;span class="nv"&gt;frame-time&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;render&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="nv"&gt;quit&lt;/span&gt;
      &lt;span class="ss"&gt;'done&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;run-game-loop&lt;/span&gt;
        &lt;span class="nv"&gt;Δt&lt;/span&gt;
        &lt;span class="nv"&gt;t&lt;/span&gt;
        &lt;span class="nv"&gt;new-time&lt;/span&gt;
        &lt;span class="nv"&gt;lag&lt;/span&gt;
        &lt;span class="nv"&gt;simulate&lt;/span&gt;
        &lt;span class="nv"&gt;render&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt;= &lt;/span&gt;&lt;span class="nv"&gt;t&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;* &lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;jiffies-per-second&lt;/span&gt;&lt;span class="p"&gt;))))))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;First we measure the current real time when the loop begins, followed by the
time it took for the last frame to finish. This &lt;code&gt;frame-time&lt;/code&gt; is the time we
have to simulate, plus whatever leftover &lt;code&gt;lag&lt;/code&gt; we had from the previous
iteration. So we start the &lt;code&gt;Δt&lt;/code&gt; emitter and store the returned values as the
new &lt;code&gt;t&lt;/code&gt; and &lt;code&gt;lag&lt;/code&gt;. Finally we render the output and run the next iteration. In
the code above I have set up the &lt;code&gt;quit&lt;/code&gt; boolean to be &lt;code&gt;#f&lt;/code&gt; after simulating ten
seconds, but in reality you would want the condition to depend on user input or
something more sensible.&lt;/p&gt;
&lt;p&gt;Here is what the complete function looks like:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;;; Run the game loop with fixed time step Δt.&lt;/span&gt;
&lt;span class="c1"&gt;;;;&lt;/span&gt;
&lt;span class="c1"&gt;;;; Parameters:&lt;/span&gt;
&lt;span class="c1"&gt;;;;   t         Total simulation time which has passed so far&lt;/span&gt;
&lt;span class="c1"&gt;;;;   Δt        The fixed tick rate&lt;/span&gt;
&lt;span class="c1"&gt;;;;   time      Total real-world time since the first iteration&lt;/span&gt;
&lt;span class="c1"&gt;;;;   lag       How much the simulation is behind real time&lt;/span&gt;
&lt;span class="c1"&gt;;;;   simulate  Callback to execute on every tick&lt;/span&gt;
&lt;span class="c1"&gt;;;;   render    Callback to execute every frame&lt;/span&gt;
&lt;span class="c1"&gt;;;;   quit      Whether to exit the game loop&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;run-game-loop&lt;/span&gt; &lt;span class="nv"&gt;Δt&lt;/span&gt; &lt;span class="nv"&gt;t&lt;/span&gt; &lt;span class="nv"&gt;time&lt;/span&gt; &lt;span class="nv"&gt;lag&lt;/span&gt; &lt;span class="nv"&gt;simulate&lt;/span&gt; &lt;span class="nv"&gt;render&lt;/span&gt; &lt;span class="nv"&gt;quit&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

  &lt;span class="c1"&gt;;; Emit a Δt signal for simulation&lt;/span&gt;
  &lt;span class="c1"&gt;;;&lt;/span&gt;
  &lt;span class="c1"&gt;;; Parameters:&lt;/span&gt;
  &lt;span class="c1"&gt;;;  t    Virtual time that has passed so far in the simulation&lt;/span&gt;
  &lt;span class="c1"&gt;;;  lag  How much the simulation is behind real time&lt;/span&gt;
  &lt;span class="c1"&gt;;;&lt;/span&gt;
  &lt;span class="c1"&gt;;; Returns: The time the simulation has been advanced by and the remaining&lt;/span&gt;
  &lt;span class="c1"&gt;;; lag.&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;emit-Δt-signal&lt;/span&gt; &lt;span class="nv"&gt;t&lt;/span&gt; &lt;span class="nv"&gt;lag&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;lt; &lt;/span&gt;&lt;span class="nv"&gt;lag&lt;/span&gt; &lt;span class="nv"&gt;Δt&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;values &lt;/span&gt;&lt;span class="nv"&gt;t&lt;/span&gt; &lt;span class="nv"&gt;lag&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;; We cannot fit in any more ticks, return&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;begin&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;simulate&lt;/span&gt; &lt;span class="nv"&gt;t&lt;/span&gt; &lt;span class="nv"&gt;Δt&lt;/span&gt; &lt;span class="nv"&gt;lag&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;emit-Δt-signal&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="nv"&gt;t&lt;/span&gt; &lt;span class="nv"&gt;Δt&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="nv"&gt;lag&lt;/span&gt; &lt;span class="nv"&gt;Δt&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;

  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let* &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;new-time&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;real-time&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;frame-time&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="nv"&gt;new-time&lt;/span&gt; &lt;span class="nv"&gt;time&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt; &lt;span class="c1"&gt;; How long the last frame took to compute&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;let-values&lt;/span&gt; &lt;span class="p"&gt;(((&lt;/span&gt;&lt;span class="nf"&gt;t&lt;/span&gt; &lt;span class="nv"&gt;lag&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;emit-Δt-signal&lt;/span&gt; &lt;span class="nv"&gt;t&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="nv"&gt;lag&lt;/span&gt; &lt;span class="nv"&gt;frame-time&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;render&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="nv"&gt;quit&lt;/span&gt;
        &lt;span class="ss"&gt;'done&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;run-game-loop&lt;/span&gt; &lt;span class="nv"&gt;Δt&lt;/span&gt; &lt;span class="nv"&gt;t&lt;/span&gt; &lt;span class="nv"&gt;new-time&lt;/span&gt; &lt;span class="nv"&gt;lag&lt;/span&gt; &lt;span class="nv"&gt;simulate&lt;/span&gt; &lt;span class="nv"&gt;render&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt;= &lt;/span&gt;&lt;span class="nv"&gt;t&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;* &lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;jiffies-per-second&lt;/span&gt;&lt;span class="p"&gt;))))))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Let's take it for a test ride.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;t&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;Δt&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;/ &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;jiffies-per-second&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;time&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;real-time&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;lag&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;quit&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;run-game-loop&lt;/span&gt; &lt;span class="nv"&gt;Δt&lt;/span&gt; &lt;span class="nv"&gt;t&lt;/span&gt; &lt;span class="nv"&gt;time&lt;/span&gt; &lt;span class="nv"&gt;lag&lt;/span&gt; &lt;span class="nv"&gt;simulate&lt;/span&gt; &lt;span class="nv"&gt;render&lt;/span&gt; &lt;span class="nv"&gt;quit&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This will run the loop with two simulations per second.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
&amp;gt; (load "loop.scm")
Simulating with t=0, Δt=500, lag=1000
Simulating with t=500, Δt=500, lag=500
Rendering...
Simulating with t=1000, Δt=500, lag=1000
Simulating with t=1500, Δt=500, lag=500
Rendering...
Simulating with t=2000, Δt=500, lag=1000
Simulating with t=2500, Δt=500, lag=500
Rendering...
Simulating with t=3000, Δt=500, lag=1000
Simulating with t=3500, Δt=500, lag=500
Rendering...
Simulating with t=4000, Δt=500, lag=1000
Simulating with t=4500, Δt=500, lag=500
Rendering...
Simulating with t=5000, Δt=500, lag=1000
Simulating with t=5500, Δt=500, lag=500
Rendering...
Simulating with t=6000, Δt=500, lag=1000
Simulating with t=6500, Δt=500, lag=500
Rendering...
Simulating with t=7000, Δt=500, lag=1000
Simulating with t=7500, Δt=500, lag=500
Rendering...
Simulating with t=8000, Δt=500, lag=1000
Simulating with t=8500, Δt=500, lag=500
Rendering...
Simulating with t=9000, Δt=500, lag=1000
Simulating with t=9500, Δt=500, lag=500
Rendering...
Simulating with t=10000, Δt=500, lag=1000
Simulating with t=10500, Δt=500, lag=500
Rendering...
&lt;/pre&gt;
&lt;p&gt;As we can see, we get two simulations per frame since each frame is one second.
Let's make it a bit more interesting: a game should run at 60 frames per
second, that's about 16ms per frame. The simulation will run at 50Hz, that's
20ms per &lt;code&gt;Δt&lt;/code&gt;. This means that there will be times when we have to skip
simulation for an entire frame until there is enough lag accumulated. In
particular the first frame will only have 16ms of lag.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;;; Adjusted clock&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="nv"&gt;real-time&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;time&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda &lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;t&lt;/span&gt; &lt;span class="nv"&gt;time&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="c1"&gt;;; Increment by 1/60th of a second&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;set! &lt;/span&gt;&lt;span class="nv"&gt;time&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="nv"&gt;time&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;floor-quotient&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;jiffies-per-second&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;60&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
        &lt;span class="nv"&gt;t&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;

&lt;span class="c1"&gt;;;; Adjusted Δt starting value&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;t&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;Δt&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;/ &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;jiffies-per-second&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;50&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;time&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;real-time&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;lag&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;quit&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;run-game-loop&lt;/span&gt; &lt;span class="nv"&gt;Δt&lt;/span&gt; &lt;span class="nv"&gt;t&lt;/span&gt; &lt;span class="nv"&gt;time&lt;/span&gt; &lt;span class="nv"&gt;lag&lt;/span&gt; &lt;span class="nv"&gt;simulate&lt;/span&gt; &lt;span class="nv"&gt;render&lt;/span&gt; &lt;span class="nv"&gt;quit&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here is the output:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
&amp;gt; (load "loop.scm")
Rendering...
Simulating with t=0, Δt=20, lag=32
Rendering...
Simulating with t=20, Δt=20, lag=28
Rendering...
Simulating with t=40, Δt=20, lag=24
Rendering...
Simulating with t=60, Δt=20, lag=20
Rendering...
Rendering...
Simulating with t=80, Δt=20, lag=32
Rendering...
Simulating with t=100, Δt=20, lag=28
Rendering...
Simulating with t=120, Δt=20, lag=24
Rendering...
Simulating with t=140, Δt=20, lag=20
Rendering...
Rendering...
Simulating with t=160, Δt=20, lag=32
Rendering...
Simulating with t=180, Δt=20, lag=28
Rendering...
Simulating with t=200, Δt=20, lag=24
Rendering...
Simulating with t=220, Δt=20, lag=20
Rendering...
Rendering...
&lt;/pre&gt;
&lt;p&gt;We see that the first frame ran without simulation because there was not enough
lag. The second frame had enough lag for one simulation and left 12ms lag for
the next frame. The third frame had thus 12ms plus its own 16ms for a total of
28ms of lag. As we can see the lag keeps getting shorter and shorter every
frame until in the sixth frame we reach the point where there is not enough lag
and we have to skip simulation for another frame.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="conclusion"&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;We now have a purely functional implementation of a game loop with fixed time
step. I haven't bothered to implement the extra interpolation found in the
original article since that only involves the renderer. It is very simple to
compute the interpolation factor:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;;; Add an α parameter&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;render&lt;/span&gt; &lt;span class="nv"&gt;α&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;;;; Inside the game loop&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;render&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;/ &lt;/span&gt;&lt;span class="nv"&gt;lag&lt;/span&gt; &lt;span class="nv"&gt;Δt&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Since the lag is less than &lt;code&gt;Δt&lt;/code&gt; the &lt;code&gt;α&lt;/code&gt; is between zero (inclusive) and one
(exclusive). Another fun idea would have been to make the time increment of
&lt;code&gt;real-time&lt;/code&gt; random to simulate a fluctuating frame rate.&lt;/p&gt;
&lt;p&gt;In my opinion he functional version is somewhat harder to trace through, but
the underlying idea is easier to see than in the imperative implementation. The
functional nature of my implementation has allowed me to unravel the problem
from inside-out; I started with the &lt;code&gt;simulate&lt;/code&gt; function, then asked myself how
to drive that, came up with &lt;code&gt;emit-Δt-signal&lt;/code&gt; and finally drove that one by
calling it from &lt;code&gt;run-game-loop&lt;/code&gt;. In contrast, in the imperative implementation
Glenn Fiedler started with the game loop and then worked his way down to the
simulation with the fixed time step.&lt;/p&gt;
&lt;/div&gt;
</content></entry><entry><title>Creating a mock REPL on Unix</title><link href="http://hiphish.github.io/blog/2017/05/13/mock-repl-unix/" rel="alternate"></link><published>2017-05-13T00:00:00+02:00</published><updated>2017-05-13T00:00:00+02:00</updated><author><name>HiPhish</name></author><id>tag:hiphish.github.io,2017-05-13:/blog/2017/05/13/mock-repl-unix/</id><summary type="html">&lt;p&gt;During the development of &lt;a class="reference external" href="https://gitlab.com/HiPhish/repl.nvim/"&gt;REPL.nvim&lt;/a&gt; I had to be able to test the plugin
without relying on any particular REPL present on the development system. The
solution was to create a mock REPL, a shell script which acts like a really
dumb REPL. Here is the code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;EOF&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;false …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;During the development of &lt;a class="reference external" href="https://gitlab.com/HiPhish/repl.nvim/"&gt;REPL.nvim&lt;/a&gt; I had to be able to test the plugin
without relying on any particular REPL present on the development system. The
solution was to create a mock REPL, a shell script which acts like a really
dumb REPL. Here is the code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;EOF&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;false&lt;/span&gt;

&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s1"&gt;'This is a dummy REPL, it does nothing and comes with no warranty.'&lt;/span&gt;
&lt;span class="k"&gt;until&lt;/span&gt; &lt;span class="nv"&gt;$EOF&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
        &lt;span class="nb"&gt;printf&lt;/span&gt; &lt;span class="s1"&gt;'&amp;gt;&amp;gt;&amp;gt; '&lt;/span&gt;
        &lt;span class="nb"&gt;read&lt;/span&gt; -r &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="nv"&gt;EOF&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'true'&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; ! &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$REPLY&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;then&lt;/span&gt; &lt;span class="k"&gt;continue&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;fi&lt;/span&gt;
        &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$REPLY&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
&lt;span class="k"&gt;done&lt;/span&gt;
&lt;span class="c1"&gt;# Terminating new line if there was no reply&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; ! &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$REPLY&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;then&lt;/span&gt; &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s1"&gt;''&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;fi&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The first line is a simple state variable which will be set to &lt;code&gt;true&lt;/code&gt; once the
user presses &lt;code&gt;^D&lt;/code&gt;. As long as the variable remains &lt;code&gt;false&lt;/code&gt; the loop will keep
running.&lt;/p&gt;
&lt;p&gt;Next comes the actual &lt;em&gt;Loop&lt;/em&gt; part of the REPL; it prints a prompt and then
reads a line indefinitely. The &lt;em&gt;Read&lt;/em&gt; part is implemented using the built-in
&lt;code&gt;read&lt;/code&gt; to store the result in the implicit variable &lt;code&gt;$REPLY&lt;/code&gt;. Should &lt;code&gt;read&lt;/code&gt;
read &lt;code&gt;^D&lt;/code&gt; the exist code will be non-zero, causing the conditional &lt;code&gt;||&lt;/code&gt; to set
the &lt;code&gt;EOF&lt;/code&gt; variable to &lt;code&gt;true&lt;/code&gt;. This is our exit mechanism out of the REPL. There
is no &lt;em&gt;Evaluate&lt;/em&gt; part since this is a mock REPL (or you could say that any
input evaluates to itself). Finally the &lt;em&gt;Print&lt;/em&gt; part is implemented by using
&lt;code&gt;echo&lt;/code&gt; to echo back the input.&lt;/p&gt;
&lt;p&gt;Technically the REPL could also be implemented with less code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;EOF&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;false&lt;/span&gt;
&lt;span class="k"&gt;until&lt;/span&gt; &lt;span class="nv"&gt;$EOF&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
        &lt;span class="nb"&gt;printf&lt;/span&gt; &lt;span class="s1"&gt;'&amp;gt;&amp;gt;&amp;gt; '&lt;/span&gt;
        &lt;span class="nb"&gt;read&lt;/span&gt; -r &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="nv"&gt;EOF&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'true'&lt;/span&gt;
        &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$REPLY&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
&lt;span class="k"&gt;done&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The additional code is just to give the REPL some extra polish. It's not really
needed if no human will never use it, but I like the extra touch. The first
line&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; ! &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$REPLY&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;then&lt;/span&gt; &lt;span class="k"&gt;continue&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;fi&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;prevents the loop from reaching the &lt;code&gt;echo&lt;/code&gt; if &lt;code&gt;$REPLY&lt;/code&gt; is an empty string.
Without it if the user does not enter any text an empty line would be printed:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
# Without extra touch
&amp;gt;&amp;gt;&amp;gt; foo
foo
&amp;gt;&amp;gt;&amp;gt;

&amp;gt;&amp;gt;&amp;gt; bar
bar

# With textra touch
&amp;gt;&amp;gt;&amp;gt; foo
foo
&amp;gt;&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; bar
bar
&lt;/pre&gt;
&lt;p&gt;The other line&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; ! &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$REPLY&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;then&lt;/span&gt; &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s1"&gt;''&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;fi&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;causes &lt;code&gt;echo&lt;/code&gt; to display an empty string. This empty string will move the shell
prompt onto the next line:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
# Without extra polish
sh-3.2$ sh mock-repl.sh
This is a dummy REPL, it does nothing and comes with no warranty.
&amp;gt;&amp;gt;&amp;gt; foo
foo
&amp;gt;&amp;gt;&amp;gt; sh-3.2$

# With extra polish
sh-3.2$ sh mock-repl.sh
This is a dummy REPL, it does nothing and comes with no warranty.
&amp;gt;&amp;gt;&amp;gt; foo
foo
&amp;gt;&amp;gt;&amp;gt; ^D
sh-3.2$
&lt;/pre&gt;
&lt;p&gt;The mock REPL can then be invoked like any other shell script and be used in
place of a real REPL program when testing. That way we do not have to be wary
of any side effects and the developer does not need to have any particular
program installed on their system.&lt;/p&gt;
</content></entry><entry><title>Outlining of HTML pages is fundamentally broken</title><link href="http://hiphish.github.io/blog/2017/04/25/html-outline-fundamentally-broken/" rel="alternate"></link><published>2017-04-25T00:00:00+02:00</published><updated>2017-04-25T00:00:00+02:00</updated><author><name>HiPhish</name></author><id>tag:hiphish.github.io,2017-04-25:/blog/2017/04/25/html-outline-fundamentally-broken/</id><summary type="html">&lt;p&gt;If you were to run the Workshop through an HTML validator you would notice a
lot of warnings about the document outline. What is going on here? HTML 5
defines an &lt;a class="reference external" href="https://www.w3.org/TR/html5/sections.html#outline"&gt;outline algorithm&lt;/a&gt; which allows browsers and assistive
technologies to create an outline of the page. In theory a blind …&lt;/p&gt;</summary><content type="html">&lt;p&gt;If you were to run the Workshop through an HTML validator you would notice a
lot of warnings about the document outline. What is going on here? HTML 5
defines an &lt;a class="reference external" href="https://www.w3.org/TR/html5/sections.html#outline"&gt;outline algorithm&lt;/a&gt; which allows browsers and assistive
technologies to create an outline of the page. In theory a blind person could
ask their reader for the outline of the page and get a sort of table of
contents which they could use to quickly jump to a specific part of the page.&lt;/p&gt;
&lt;p&gt;The problem is the “in theory” part. The outline algorithm has not been
implemented in any of the common browsers and it probably &lt;a class="reference external" href="http://html5doctor.com/computer-says-no-to-html5-document-outline/"&gt;never will be&lt;/a&gt;.
Instead authors are supposed to use the rank of headings &lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt; through &lt;code&gt;&amp;lt;h6&amp;gt;&lt;/code&gt;
to convey the outline of the document, which is a fundamentally broken concept.&lt;/p&gt;
&lt;div class="section" id="html-does-not-know-what-it-wants-to-be"&gt;
&lt;h2&gt;HTML does not know what it wants to be&lt;/h2&gt;
&lt;p&gt;HTML was originally an application of &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Standard_Generalized_Markup_Language"&gt;SGML&lt;/a&gt;, it was meant to mark up documents.
As such the concept of &lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt; through &lt;code&gt;&amp;lt;h6&amp;gt;&lt;/code&gt; made sense. The contents of the
document would be inside the &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; and would flow in a one-dimensional way
from top to bottom.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;body&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
  &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;h1&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;About Grid Framework&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;h1&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
  Lorem ipsum...

  &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;h2&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;Advantages of Grid Framework&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;h2&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;

  &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;h3&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;Advantages over other solutions&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;h3&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
  Lorem ipsum...

  &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;h3&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;Advantages over self-made solutions&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;h3&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
  Lorem ipsum...

  &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;h2&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;Features of Grid Framework&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;h2&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
  Lorem ipsum...
&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;body&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The number of ranks was hard-coded, but six is enough for a document. The
headings could be used as targets to jump to, and since the document is
one-dimensional there is no ambiguity as to what belongs under which heading.&lt;/p&gt;
&lt;p&gt;Of course a product website that looks like it was written in a word processor
does not look appealing, so people began stretching HTML beyond what it was
meant to be. If you look at the source code of the Workshop you will see that
everything is built in a tree-like fashion. You have sections within sections,
multiple navigation items, and two-dimensional layout (some sites even have
three-dimensional layout with popup elements).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="html-sectioning-tags-solve-the-problem"&gt;
&lt;h2&gt;HTML sectioning tags solve the problem&lt;/h2&gt;
&lt;p&gt;Prior to HTML 5 this lead to &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;-itis, where the page was littered with
&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; elements with no semantic meaning. This is bad, HTML is supposed to be
all about the content, not the layout. HTML 5 added semantic sectioning, which
solved the problem: the one-dimensional structure was abandoned in favour of a
tree-based structure. Authors can still write classic one-dimensional
documents, but they can also structure the page in terms of sections where
sections can contain any number of sub-sections:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;body&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
  &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;header&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;img&lt;/span&gt; &lt;span class="na"&gt;src&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"logo.svg"&lt;/span&gt;&lt;span class="p"&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;nav&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
      ...
    &lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;nav&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
  &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;header&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
  &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;section&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;header&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;...&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;header&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;main&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
      ...
    &lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;main&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;nav&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
      ...
    &lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;nav&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;aside&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
      ...
    &lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;aside&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
  &lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;section&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
  &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;footer&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
    ...
  &lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;footer&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;body&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;What about the outline though? Now I know that there is some page element for
navigation, but which kind of navigation is it? This information is conveyed by
the old heading elements. Simple enough, just add a &lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt; as the first child
of the section and you are good to go. At least that is how it is supposed to
work in theory.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-problem-with-hard-coded-heading-ranks"&gt;
&lt;h2&gt;The problem with hard-coded heading ranks&lt;/h2&gt;
&lt;p&gt;Ideally the rank of the heading does not matter to the outline algorithm. We
could use a &lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt; for every section and the algorithm would count the section
instead of looking at the rank. Unfortunately this is not implemented in any of
the major browsers and the &lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt; is treated as a page-wide top-level heading.
In other words, the nesting of our sections is lost and the outline is
completely flat.&lt;/p&gt;
&lt;p&gt;If you look at the simple example above you will notice that the &lt;code&gt;&amp;lt;main&amp;gt;&lt;/code&gt; is a
rank three element, so its proper heading would need to be &lt;code&gt;&amp;lt;h3&amp;gt;&lt;/code&gt;. This leaves
only three more ranks of headings for the contents of the &lt;code&gt;&amp;lt;main&amp;gt;&lt;/code&gt;. We are
still using the old one-dimensional outline method for multi-dimensional
content.&lt;/p&gt;
&lt;div class="section" id="lack-of-heading-ranks"&gt;
&lt;h3&gt;Lack of heading ranks&lt;/h3&gt;
&lt;p&gt;The code snippet I provided was a very simple example, in reality nesting can
go even deeper. Take the Grid Framework news blog: the list of articles has
rank four, and every article preview has rank five. If there is a heading in
the article preview itself that‘s already at rank six, the lowest rank possible
in HTML. One might argue that I should not have built so many ranks in the
first place, but I disagree; the top level (1) is the common structure for the
entire site, the next level (2) is the Grid Framework sub-site, followed by the
blog structure (3), which contains the list of articles (4). This is all
logical nesting based on the hierarchy of the page within the site.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="hard-coded-headings-break-article"&gt;
&lt;h3&gt;Hard-coded headings break &lt;code&gt;&amp;lt;article&amp;gt;&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;The problem becomes even more glaring when you consider that an &lt;code&gt;&amp;lt;article&amp;gt;&lt;/code&gt;
element is supposed to be an element that can stand on its own without the
surrounding content, such as a blog post, a comment or a product card. If the
article cannot have a rank one heading, then it can never stand on its own.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="automation-concerns"&gt;
&lt;h3&gt;Automation concerns&lt;/h3&gt;
&lt;p&gt;This is also a problem with automatic generation of pages. Take this post as an
example: while writing it I should not have to concern myself with the question
of what ranks the headings will have to have in the surrounding page. In fact,
I cannot do that, because after changing the template or uploading the post to
another service or running it through a converter the surrounding ranks could
be completely different, or the concept of surrounding ranks might not even be
applicable. Furthermore, what if I run out of ranks? This article already has
three ranks of titles, now imagine If I wanted to publish actual in-depth
documents.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="how-could-the-problem-be-solved"&gt;
&lt;h2&gt;How could the problem be solved?&lt;/h2&gt;
&lt;p&gt;The &lt;a class="reference external" href="http://html5doctor.com/computer-says-no-to-html5-document-outline/#comment-2130593"&gt;last comment&lt;/a&gt; in the &lt;a class="reference external" href="http://html5doctor.com/computer-says-no-to-html5-document-outline/"&gt;above linked&lt;/a&gt; article describes a good solution:
use the nesting of a section for the global rank and use &lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt; through &lt;code&gt;&amp;lt;h6&amp;gt;&lt;/code&gt;
for local ranks within that section. Every section would begin with a &lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt;
and could contain lesser ranks, but the effective rank of each heading would be
the sum of the section‘s rank and the rank of the heading. This way it would be
possible to structure pages multi-dimensionally, but still use a
one-dimensional structure &lt;em&gt;inside&lt;/em&gt; a section.&lt;/p&gt;
&lt;p&gt;Taking this blog post as an example again, my generator would use the headings
&lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt; through &lt;code&gt;&amp;lt;h6&amp;gt;&lt;/code&gt; and the browser would figure out the true rank of a
heading based on how deep the post is actually nested inside the page.
Furthermore, since this post is an &lt;code&gt;&amp;lt;article&amp;gt;&lt;/code&gt; it could be cropped out of the
page and still make sense on its own.&lt;/p&gt;
&lt;p&gt;So what should I do with the Workshop in the meantime? Nothing. I‘m sorry, but
the current one-dimensional ranking system simply cannot be made to work with
this design. In order to make it work I would have to throw away most of the
tree-based design in favour of a flat design with barely no structure. The cost
does no outweigh the benefits. Browser manufacturers need to get their houses
in order, it cannot be that we have WebAssembly and WebGL shaders in our
browsers, but no way of generating an outline for blind people. This is really
telling about where their priorities lie.&lt;/p&gt;
&lt;p&gt;And before anyone decides to call me unprofessional for this attitude, try
outlining the websites of some of the larger companies who hire professional
web designers to work on their sites and see what the result looks like.&lt;/p&gt;
&lt;/div&gt;
</content><category term="html"></category><category term="rant"></category><category term="outline"></category></entry><entry><title>Introducing info.vim</title><link href="http://hiphish.github.io/blog/2016/11/20/introducing-infovim/" rel="alternate"></link><published>2016-11-20T00:00:00+01:00</published><updated>2016-11-20T00:00:00+01:00</updated><author><name>HiPhish</name></author><id>tag:hiphish.github.io,2016-11-20:/blog/2016/11/20/introducing-infovim/</id><summary type="html">&lt;p&gt;There  is a  new project  up at  the Workshop:  &lt;a class="reference external" href="https://gitlab.com/HiPhish/info.vim"&gt;info.vim&lt;/a&gt;, a  Vim plugin  which
implements a  complete reader and browser  for info documents from  within Vim.
This is similar to the standalone &lt;code&gt;info&lt;/code&gt; program or the Emacs info mode.&lt;/p&gt;
&lt;p&gt;Info documents  are generally produced by  the &lt;a class="reference external" href="https://www.gnu.org/software/texinfo/"&gt;Texinfo&lt;/a&gt; program, which …&lt;/p&gt;</summary><content type="html">&lt;p&gt;There  is a  new project  up at  the Workshop:  &lt;a class="reference external" href="https://gitlab.com/HiPhish/info.vim"&gt;info.vim&lt;/a&gt;, a  Vim plugin  which
implements a  complete reader and browser  for info documents from  within Vim.
This is similar to the standalone &lt;code&gt;info&lt;/code&gt; program or the Emacs info mode.&lt;/p&gt;
&lt;p&gt;Info documents  are generally produced by  the &lt;a class="reference external" href="https://www.gnu.org/software/texinfo/"&gt;Texinfo&lt;/a&gt; program, which  is also
the official documentation format for the GNU project. This means that a lot of
important manuals, such  as the Bourne Again Shell user  manual, are written in
this format. One could  read the manual in HTML or PDF,  but that means leaving
the editor and  interrupting the workflow. Another alternative would  be to run
standalone &lt;code&gt;info&lt;/code&gt; from within a Neovim terminal buffer, but even that's more of
a workaround than a  real solution, plus you have to  learn the weird interface
of standalone  &lt;code&gt;info&lt;/code&gt;. Until  now Vim  users had  no real  way of  reading info
documents without interruption.&lt;/p&gt;
&lt;div class="section" id="a-new-info-reader"&gt;
&lt;h2&gt;A new info reader&lt;/h2&gt;
&lt;p&gt;The best way to get  and idea of info.vim is to see it  right in action in this
asccicast:&lt;/p&gt;
&lt;a class="reference external image-reference" href="https://asciinema.org/a/92884"&gt;&lt;img alt="Screencast of using Info.vim" class="align-center img-responsive" src="https://asciinema.org/a/92884.png" style="width: 50%;"/&gt;&lt;/a&gt;
&lt;p&gt;Opening the manual to the Bourne Again Shell is as easy as typing&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;Info bash
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;on the Vim command line. Similar to  standalone &lt;code&gt;info&lt;/code&gt; you can also give a node
to jump to:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;Info bash introduction
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Info.vim uses the same way of finding  files and nodes as standalone &lt;code&gt;info&lt;/code&gt;, so
even  a short  form like  &lt;code&gt;:Info bash intro&lt;/code&gt;  would  find the  right node.  The
command will open a new window or  use an existing window, similar to how Vim's
&lt;code&gt;:help&lt;/code&gt; works.  You can even  use the same  modifier like &lt;code&gt;:vertical&lt;/code&gt;,  it will
works exactly as you would expect.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="navigating-info-documents"&gt;
&lt;h2&gt;Navigating info documents&lt;/h2&gt;
&lt;p&gt;Of course reading a  node of the manual is only half  of what an implementation
of info  should provide.  The other  half is navigating  the manual.  For every
navigation  a corresponding  Vim command  is provided:  &lt;code&gt;:InfoUp&lt;/code&gt;, &lt;code&gt;:InfoNext&lt;/code&gt;,
&lt;code&gt;:InfoPrev&lt;/code&gt;,  &lt;code&gt;:Menu&lt;/code&gt;,   &lt;code&gt;:Follow&lt;/code&gt;  and   &lt;code&gt;:GotoNode&lt;/code&gt;.  All   commands  support
tab-completion (where  applicable) and there  is a  prompt version of  each one
that can be mapped to a key by the user:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;nmap &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;buffer&lt;span class="p"&gt;&amp;gt;&lt;/span&gt; gu &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;Plug&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;InfoUp
nmap &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;buffer&lt;span class="p"&gt;&amp;gt;&lt;/span&gt; gn &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;Plug&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;InfoNext
nmap &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;buffer&lt;span class="p"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;gp&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;Plug&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;InfoPrev
nmap &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;buffer&lt;span class="p"&gt;&amp;gt;&lt;/span&gt; gm &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;Plug&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;InfoMenu
nmap &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;buffer&lt;span class="p"&gt;&amp;gt;&lt;/span&gt; gf &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;Plug&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;InfoFollow
nmap &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;buffer&lt;span class="p"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;go&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;Plug&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;InfoGoto
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="advanced-info"&gt;
&lt;h2&gt;Advanced info&lt;/h2&gt;
&lt;p&gt;For those who like  to dig deeper into the meat and build  their own scripts on
top of  info.vim there are two  very handy features: the  &lt;code&gt;b:info&lt;/code&gt; variable and
info URIs. &lt;code&gt;b:info&lt;/code&gt;  is a buffer-local dictionary that  holds information about
the current node, such  as sibling nodes, its file or a list  of menu items. An
info URI  is a  special URI  that can be  used to  identify info  documents. By
executing&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c"&gt;" We had to escape the '%' with '\%' because of Vim&lt;/span&gt;
&lt;span class="p"&gt;:&lt;/span&gt;edit info:&lt;span class="sr"&gt;//&lt;/span&gt;bash.info&lt;span class="sr"&gt;/What\%20is\%20Bash\%3f/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;you will  open the corresponding node  right in your current  window. Much like
with the &lt;code&gt;:Info&lt;/code&gt; command you can  also use a short URI like &lt;code&gt;info://bash/what&lt;/code&gt;.
Info.vim  is clever  and will  normalise  your URI  so  you don't  end up  with
multiple buffers all displaying the same content. With this of normalisation in
place we can  even add extra information  to the URI's query, like  a line- and
column number:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;edit info:&lt;span class="sr"&gt;/bash.info/&lt;/span&gt;What\%&lt;span class="m"&gt;20&lt;/span&gt;is\%&lt;span class="m"&gt;20&lt;/span&gt;Bash\%&lt;span class="m"&gt;3&lt;/span&gt;f/?line&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="m"&gt;3&lt;/span&gt;&amp;amp;column&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="m"&gt;7&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So go ahead, download info.vim and browse all those info manuals that have been
collecting dust  on your  hard drive  so far,  and don't  forget to  report any
issues you might come across.&lt;/p&gt;
&lt;/div&gt;
</content><category term="vim"></category><category term="info"></category></entry><entry><title>Highlighting NSImageView the right way</title><link href="http://hiphish.github.io/blog/2016/06/25/highlighting-nsimageview/" rel="alternate"></link><published>2016-06-25T00:00:00+02:00</published><updated>2016-06-25T00:00:00+02:00</updated><author><name>HiPhish</name></author><id>tag:hiphish.github.io,2016-06-25:/blog/2016/06/25/highlighting-nsimageview/</id><summary type="html">&lt;p&gt;Recently  I have  been working on  a small Cocoa  app and one  of the  things I
needed to do was highlight an  &lt;code&gt;NSImageView&lt;/code&gt; when the user is hovering above it
while dragging a file.  You would think  that it's a very simple task,  and you
would be right, but judging …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Recently  I have  been working on  a small Cocoa  app and one  of the  things I
needed to do was highlight an  &lt;code&gt;NSImageView&lt;/code&gt; when the user is hovering above it
while dragging a file.  You would think  that it's a very simple task,  and you
would be right, but judging by some of the things on the internet it looks like
an unsolved problem.&lt;/p&gt;
&lt;p&gt;The difficult part about Mac development is not Objective-C, if you know C then
you can learn  Objective-C in a  few days.  The hard part is Cocoa.  Cocoa is a
very old framework,  older than .NET, Java and macOS.  A framework  this old is
guaranteed to have grown a lot  over the years and finding what you are looking
for can  be a  daunting task.  Even Apple's  own documentation  is filled  with
deprecated API calls or downright bad practice.&lt;/p&gt;
&lt;div class="section" id="the-wrong-way"&gt;
&lt;h2&gt;The wrong way&lt;/h2&gt;
&lt;p&gt;Here is how Apple's own documentation highlights an &lt;code&gt;NSImageView&lt;/code&gt; instance. The
code is from the official &lt;a class="reference external" href="https://developer.apple.com/library/mac/samplecode/CocoaDragAndDrop/Introduction/Intro.html"&gt;CocoaDragAndDrop&lt;/a&gt; example.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;-(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;drawRect:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NSRect&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;rect&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="cm"&gt;/*------------------------------------------------------&lt;/span&gt;
&lt;span class="cm"&gt;        draw method is overridden to do drop highlighing&lt;/span&gt;
&lt;span class="cm"&gt;    --------------------------------------------------------*/&lt;/span&gt;
    &lt;span class="c1"&gt;//do the usual draw operation to display the image&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;super&lt;/span&gt; &lt;span class="nl"&gt;drawRect&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;rect&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;highlight&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;//highlight by overlaying a gray border&lt;/span&gt;
        &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;NSColor&lt;/span&gt; &lt;span class="n"&gt;grayColor&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;set&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;NSBezierPath&lt;/span&gt; &lt;span class="nl"&gt;setDefaultLineWidth&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;NSBezierPath&lt;/span&gt; &lt;span class="nl"&gt;strokeRect&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;rect&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;There are other  implementations on the internet,  but those can be excused for
not being official. They all have the same fundamental problem anyway,  so I'll
just use this one for illustration.&lt;/p&gt;
&lt;p&gt;The implementation  looks simple  enough and works,  but only  as long  as your
&lt;code&gt;NSImageView&lt;/code&gt; instance satisfies the assumptions made here.  We assume that our
view object will always have  the outline of a rectangle and we assume that the
chosen colour  will always  be adequate.  In my  case the first  assumption was
already broken from the start because I was using the &lt;em&gt;Bezel&lt;/em&gt; style for my view
objects, a style that is part of Cocoa itself. There is also no telling when in
the future Apple might change the default colours, making your choice of colour
inadequate. And that's not even going into portability if you want to use
GNUStep to port your app to other operating systems.&lt;/p&gt;
&lt;p&gt;What we want is an abstraction.  Abstractions provide us with a clean interface
that can remain stable while  the underlying implementation  can change wildly.
Cocoa has abstractions everywhere, such as using &lt;code&gt;NSURL&lt;/code&gt; for file paths instead
of C  strings  or even &lt;code&gt;NSString&lt;/code&gt;.  Doing things  your own  way should  only be
reserved for when  you actually have control over the underlying code.  So if I
were  to  draw my  own  shapes  for an  &lt;code&gt;NSView&lt;/code&gt; I  would  also  be comfortable
hard-coding my own highlighting.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-right-way"&gt;
&lt;h2&gt;The right way™&lt;/h2&gt;
&lt;p&gt;As it turns out  Cocoa already provides  us with the  means of abstraction  for
highlighting.  The &lt;code&gt;NSControl&lt;/code&gt; class has the &lt;code&gt;highlighted&lt;/code&gt; property,  which has
the getter &lt;code&gt;isHighlighted&lt;/code&gt;,  so we don't need  a new property.  For drawing the
actual highlight &lt;code&gt;NSView&lt;/code&gt;  provides the method &lt;code&gt;drawFocusRingMask&lt;/code&gt;.  Subclasses
can override  the property  to implement  their own  highlighting  and  luckily
&lt;code&gt;NSImageView&lt;/code&gt; does exacly that.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;drawRect:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NSRect&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;dirtyRect&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;super&lt;/span&gt; &lt;span class="nl"&gt;drawRect&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;dirtyRect&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt; &lt;span class="n"&gt;isHighlighted&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt; &lt;span class="n"&gt;drawFocusRingMask&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now your code is future-proof and will work regardless of the shape you choose.
Well, at least until Apple deprecates this method.&lt;/p&gt;
&lt;/div&gt;
</content><category term="cocoa"></category></entry></feed>