<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>HiPhish's Workshop</title><link href="http://hiphish.github.io/" rel="alternate"></link><link href="http://192.168.0.190:8000/blog/categories/misc/atom.xml" rel="self"></link><id>http://hiphish.github.io/</id><updated>2016-11-20T00:00:00+01:00</updated><entry><title>Introducing info.vim</title><link href="http://hiphish.github.io/blog/2016/11/20/introducing-infovim/" rel="alternate"></link><published>2016-11-20T00:00:00+01:00</published><updated>2016-11-20T00:00:00+01:00</updated><author><name>HiPhish</name></author><id>tag:hiphish.github.io,2016-11-20:blog/2016/11/20/introducing-infovim/</id><summary type="html">&lt;p&gt;There  is a  new project  up at  the Workshop:  &lt;a class="reference external" href="https://gitlab.com/HiPhish/info.vim"&gt;info.vim&lt;/a&gt;, a  Vim plugin  which
implements a  complete reader and browser  for info documents from  within Vim.
This is similar to the standalone &lt;code&gt;info&lt;/code&gt; program or the Emacs info mode.&lt;/p&gt;
&lt;p&gt;Info documents  are generally produced by  the &lt;a class="reference external" href="https://www.gnu.org/software/texinfo/"&gt;Texinfo&lt;/a&gt; program, which  is also
the official documentation format for the GNU project. This means that a lot of
important manuals, such  as the Bourne Again Shell user  manual, are written in
this format. One could  read the manual in HTML or PDF,  but that means leaving
the editor and  interrupting the workflow. Another alternative would  be to run
standalone &lt;code&gt;info&lt;/code&gt; from within a Neovim terminal buffer, but even that's more of
a workaround than a  real solution, plus you have to  learn the weird interface
of standalone  &lt;code&gt;info&lt;/code&gt;. Until  now Vim  users had  no real  way of  reading info
documents without interruption.&lt;/p&gt;
&lt;div class="section" id="a-new-info-reader"&gt;
&lt;h2&gt;A new info reader&lt;/h2&gt;
&lt;p&gt;The best way to get  and idea of info.vim is to see it  right in action in this
asccicast:&lt;/p&gt;
&lt;a class="reference external image-reference" href="https://asciinema.org/a/92884"&gt;&lt;img alt="Screencast of using Info.vim" class="img-responsive align-center" src="https://asciinema.org/a/92884.png" style="width: 50%;"/&gt;&lt;/a&gt;
&lt;p&gt;Opening the manual to the Bourne Again Shell is as easy as typing&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;Info bash
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;on the Vim command line. Similar to  standalone &lt;code&gt;info&lt;/code&gt; you can also give a node
to jump to:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;Info bash introduction
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Info.vim uses the same way of finding  files and nodes as standalone &lt;code&gt;info&lt;/code&gt;, so
even  a short  form like  &lt;code&gt;:Info bash intro&lt;/code&gt;  would  find the  right node.  The
command will open a new window or  use an existing window, similar to how Vim's
&lt;code&gt;:help&lt;/code&gt; works.  You can even  use the same  modifier like &lt;code&gt;:vertical&lt;/code&gt;,  it will
works exactly as you would expect.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="navigating-info-documents"&gt;
&lt;h2&gt;Navigating info documents&lt;/h2&gt;
&lt;p&gt;Of course reading a  node of the manual is only half  of what an implementation
of info  should provide.  The other  half is navigating  the manual.  For every
navigation  a corresponding  Vim command  is provided:  &lt;code&gt;:InfoUp&lt;/code&gt;, &lt;code&gt;:InfoNext&lt;/code&gt;,
&lt;code&gt;:InfoPrev&lt;/code&gt;,  &lt;code&gt;:Menu&lt;/code&gt;,   &lt;code&gt;:Follow&lt;/code&gt;  and   &lt;code&gt;:GotoNode&lt;/code&gt;.  All   commands  support
tab-completion (where  applicable) and there  is a  prompt version of  each one
that can be mapped to a key by the user:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;nmap &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;buffer&lt;span class="p"&gt;&amp;gt;&lt;/span&gt; gu &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;Plug&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;InfoUp
nmap &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;buffer&lt;span class="p"&gt;&amp;gt;&lt;/span&gt; gn &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;Plug&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;InfoNext
nmap &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;buffer&lt;span class="p"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;gp&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;Plug&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;InfoPrev
nmap &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;buffer&lt;span class="p"&gt;&amp;gt;&lt;/span&gt; gm &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;Plug&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;InfoMenu
nmap &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;buffer&lt;span class="p"&gt;&amp;gt;&lt;/span&gt; gf &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;Plug&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;InfoFollow
nmap &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;buffer&lt;span class="p"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;go&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;Plug&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;InfoGoto
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="advanced-info"&gt;
&lt;h2&gt;Advanced info&lt;/h2&gt;
&lt;p&gt;For those who like  to dig deeper into the meat and build  their own scripts on
top of  info.vim there are two  very handy features: the  &lt;code&gt;b:info&lt;/code&gt; variable and
info URIs. &lt;code&gt;b:info&lt;/code&gt;  is a buffer-local dictionary that  holds information about
the current node, such  as sibling nodes, its file or a list  of menu items. An
info URI  is a  special URI  that can be  used to  identify info  documents. By
executing&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c"&gt;" We had to escape the '%' with '\%' because of Vim&lt;/span&gt;
&lt;span class="p"&gt;:&lt;/span&gt;edit info:&lt;span class="sr"&gt;//&lt;/span&gt;bash.info&lt;span class="sr"&gt;/What\%20is\%20Bash\%3f/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;you will  open the corresponding node  right in your current  window. Much like
with the &lt;code&gt;:Info&lt;/code&gt; command you can  also use a short URI like &lt;code&gt;info://bash/what&lt;/code&gt;.
Info.vim  is clever  and will  normalise  your URI  so  you don't  end up  with
multiple buffers all displaying the same content. With this of normalisation in
place we can  even add extra information  to the URI's query, like  a line- and
column number:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;edit info:&lt;span class="sr"&gt;/bash.info/&lt;/span&gt;What\%&lt;span class="m"&gt;20&lt;/span&gt;is\%&lt;span class="m"&gt;20&lt;/span&gt;Bash\%&lt;span class="m"&gt;3&lt;/span&gt;f/?line&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="m"&gt;3&lt;/span&gt;&amp;amp;column&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="m"&gt;7&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So go ahead, download info.vim and browse all those info manuals that have been
collecting dust  on your  hard drive  so far,  and don't  forget to  report any
issues you might come across.&lt;/p&gt;
&lt;/div&gt;
</summary><category term="vim"></category><category term="info"></category></entry><entry><title>Highlighting NSImageView the right way</title><link href="http://hiphish.github.io/blog/2016/06/25/highlighting-nsimageview/" rel="alternate"></link><published>2016-06-25T00:00:00+02:00</published><updated>2016-06-25T00:00:00+02:00</updated><author><name>HiPhish</name></author><id>tag:hiphish.github.io,2016-06-25:blog/2016/06/25/highlighting-nsimageview/</id><summary type="html">&lt;p&gt;Recently  I have  been working on  a small Cocoa  app and one  of the  things I
needed to do was highlight an  &lt;code&gt;NSImageView&lt;/code&gt; when the user is hovering above it
while dragging a file.  You would think  that it's a very simple task,  and you
would be right, but judging by some of the things on the internet it looks like
an unsolved problem.&lt;/p&gt;
&lt;p&gt;The difficult part about Mac development is not Objective-C, if you know C then
you can learn  Objective-C in a  few days.  The hard part is Cocoa.  Cocoa is a
very old framework,  older than .NET, Java and macOS.  A framework  this old is
guaranteed to have grown a lot  over the years and finding what you are looking
for can  be a  daunting task.  Even Apple's  own documentation  is filled  with
deprecated API calls or downright bad practice.&lt;/p&gt;
&lt;div class="section" id="the-wrong-way"&gt;
&lt;h2&gt;The wrong way&lt;/h2&gt;
&lt;p&gt;Here is how Apple's own documentation highlights an &lt;code&gt;NSImageView&lt;/code&gt; instance. The
code is from the official &lt;a class="reference external" href="https://developer.apple.com/library/mac/samplecode/CocoaDragAndDrop/Introduction/Intro.html"&gt;CocoaDragAndDrop&lt;/a&gt; example.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;-(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;drawRect:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NSRect&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;rect&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="cm"&gt;/*------------------------------------------------------&lt;/span&gt;
&lt;span class="cm"&gt;        draw method is overridden to do drop highlighing&lt;/span&gt;
&lt;span class="cm"&gt;    --------------------------------------------------------*/&lt;/span&gt;
    &lt;span class="c1"&gt;//do the usual draw operation to display the image&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;super&lt;/span&gt; &lt;span class="nl"&gt;drawRect&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;rect&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;highlight&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;//highlight by overlaying a gray border&lt;/span&gt;
        &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;NSColor&lt;/span&gt; &lt;span class="n"&gt;grayColor&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;set&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;NSBezierPath&lt;/span&gt; &lt;span class="nl"&gt;setDefaultLineWidth&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;NSBezierPath&lt;/span&gt; &lt;span class="nl"&gt;strokeRect&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;rect&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;There are other  implementations on the internet,  but those can be excused for
not being official. They all have the same fundamental problem anyway,  so I'll
just use this one for illustration.&lt;/p&gt;
&lt;p&gt;The implementation  looks simple  enough and works,  but only  as long  as your
&lt;code&gt;NSImageView&lt;/code&gt; instance satisfies the assumptions made here.  We assume that our
view object will always have  the outline of a rectangle and we assume that the
chosen colour  will always  be adequate.  In my  case the first  assumption was
already broken from the start because I was using the &lt;em&gt;Bezel&lt;/em&gt; style for my view
objects, a style that is part of Cocoa itself. There is also no telling when in
the future Apple might change the default colours, making your choice of colour
inadequate. And that's not even going into portability if you want to use
GNUStep to port your app to other operating systems.&lt;/p&gt;
&lt;p&gt;What we want is an abstraction.  Abstractions provide us with a clean interface
that can remain stable while  the underlying implementation  can change wildly.
Cocoa has abstractions everywhere, such as using &lt;code&gt;NSURL&lt;/code&gt; for file paths instead
of C  strings  or even &lt;code&gt;NSString&lt;/code&gt;.  Doing things  your own  way should  only be
reserved for when  you actually have control over the underlying code.  So if I
were  to  draw my  own  shapes  for an  &lt;code&gt;NSView&lt;/code&gt; I  would  also  be comfortable
hard-coding my own highlighting.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-right-way"&gt;
&lt;h2&gt;The right way™&lt;/h2&gt;
&lt;p&gt;As it turns out  Cocoa already provides  us with the  means of abstraction  for
highlighting.  The &lt;code&gt;NSControl&lt;/code&gt; class has the &lt;code&gt;highlighted&lt;/code&gt; property,  which has
the getter &lt;code&gt;isHighlighted&lt;/code&gt;,  so we don't need  a new property.  For drawing the
actual highlight &lt;code&gt;NSView&lt;/code&gt;  provides the method &lt;code&gt;drawFocusRingMask&lt;/code&gt;.  Subclasses
can override  the property  to implement  their own  highlighting  and  luckily
&lt;code&gt;NSImageView&lt;/code&gt; does exacly that.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;drawRect:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NSRect&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;dirtyRect&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;super&lt;/span&gt; &lt;span class="nl"&gt;drawRect&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;dirtyRect&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt; &lt;span class="n"&gt;isHighlighted&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt; &lt;span class="n"&gt;drawFocusRingMask&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now your code is future-proof and will work regardless of the shape you choose.
Well, at least until Apple deprecates this method.&lt;/p&gt;
&lt;/div&gt;
</summary><category term="cocoa"></category></entry></feed>