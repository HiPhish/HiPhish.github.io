<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><title>HiPhish's Workshop</title><link rel="stylesheet" href="/css/main.css" type="text/css" media="all"/><link rel="stylesheet" href="/css/local-nav.css" type="text/css" media="all"/><link rel="stylesheet" href="/css/blog.css" type="text/css" media="all"/></head><body><header><nav id="main-navbar"><input type="checkbox" id="main-nav-hamburger" hidden="hidden"/><div><a href="/">HiPhish's Workshop</a><label for="main-nav-hamburger" hidden="hidden"></label></div><ul><li><a href="/grid-framework/">Grid Framework</a><ul><li><a href="/grid-framework/">Overview</a></li><li hidden="hidden"/><li><a href="/grid-framework/features/">Features</a></li><li><a href="/grid-framework/examples/">Examples</a></li><li><a href="/grid-framework/gallery/">Gallery</a></li><li><a href="/grid-framework/showcase/">Showcase</a></li><li><a href="/grid-framework/faq/">FAQ</a></li><li><a href=" /grid-framework/news/">News</a></li><li hidden="hidden"/><li><a href="http://forum.unity3d.com/threads/grid-framework-scripting-and-editor-plugins.144886/">Support</a></li><li hidden="hidden"/><li><a href="https://www.assetstore.unity3d.com/#/content/62498">Buy Now <span class="badge">35$</span></a></li></ul></li><li><a href="/#products">Open Source</a><ul><li><a href="https://gitlab.com/HiPhish/ntfs-clone">NTFS-Clone</a></li><li><a href="https://gitlab.com/HiPhish/IPS-Tools">IPS-Tools</a></li><li><a href="https://gitlab.com/HiPhish/roll">roll</a></li><li><a href="https://github.com/HiPhish/Newton-method">Newton's Method in C</a></li><li><a href="https://github.com/HiPhish/XeenTools">Xeen Tools</a></li><li><a href="https://github.com/HiPhish/Wolf3DExtract">Wolf3D Extract</a></li><li><a href="https://github.com/HiPhish/Game-Source-Documentation">Game Source Documentation</a></li></ul></li><li><a href="/vim/plugins/">Vim/Nvim plugins</a><ul><li><a href="https://gitlab.com/HiPhish/info.vim">Info.vim</a></li><li><a href="https://gitlab.com/HiPhish/repl.nvim">REPL.nvim</a></li><li><a href="https://gitlab.com/HiPhish/quicklisp.nvim">Quicklisp.nvim</a></li><li><a href="https://gitlab.com/HiPhish/jinja.vim">jinja.vim</a></li><li><a href="https://gitlab.com/HiPhish/neovim-guix-channel/">Guix channel</a></li></ul></li><li class="push-end"><a href="/blog/">Blog</a></li><li><a href="/about/">About</a></li></ul></nav></header><div><div class="blog"><nav class="breadcrumbs" aria-label="Breadcrumbs"><ol><li class=""><a href="../../../../">blog</a></li><li class=""><a href="../../../">2024</a></li><li class=""><a href="../../">05</a></li><li class="active">23</li><li class="active">lets-write-fizzbuzz-in-functional-style</li></ol></nav><main class="blogpost"><article><h1><a href="." title="permalink to Let's write FizzBuzz in a functional style for no good reason" rel="bookmark">Let's write FizzBuzz in a functional style for no good reason</a></h1><header class="blog-post-header"><p class="blog-post-published">published: <time datetime="2024-05-23">2024-05-23</time></p><p class="blog-post-category">categories: <a href="../../../../categories/misc/">misc</a></p><p class="blog-post-tags">tags: <a href="../../../../tags/python/">python</a>, <a href="../../../../tags/functional programming/">functional programming</a></p></header><p>Let's write yet another FizzBuzz because that's what the world needs. Here's
the twist though: ours won't be like those other fuddy-duddy lame and bloated
<a href="https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition">enterprise-grade</a> FizzBuzzes.  Oh no, we are ahead of the curve this time,
it's functional time, baby!  We will be using Python though, because that and
Javascript is the closest most of us will ever get to using a functional
programming language in production.</p><h2 id="The naive FizzBuzz">The naive FizzBuzz</h2><p>Here is how your typical programmer would write his FizzBuzz:</p><pre><code>for i in range(100):
    if i % 3 == 0 and i % 5 == 0:
        print('FizzBuzz')
    elif i % 3 == 0:
        print('Fizz')
    elif i % 5 == 0:
        print('Buzz')
    else:
        print(i)
</code></pre><p>Simple and concise, yet this won't do in today's marketplace.  Let's function
it up.</p><h2 id="The functional FizzBuzz">The functional FizzBuzz</h2><p>The first thing a real Python programmer does is separate functionality from
execution through an <code>if __name__ == '__main__'</code> check.</p><pre><code>if __name__ == '__main__':
    for i in range(100):
        if i % 3 == 0 and i % 5 == 0:
            print('FizzBuzz')
        elif i % 3 == 0:
            print('Fizz')
        elif i % 5 == 0:
            print('Buzz')
        else:
            print(i)
</code></pre><p>OK, but that's still nowhere functional, there aren't even any functions!  The
bulk of our logic is the big FizzBuzz check, so that seems like a good
candidate for a function.  And while we're at it I'm also going to
type-annotate the code because functional languages have really fancy type
systems.</p><pre><code>def fizzbuzz(i: int) -&gt; str:
    &quot;&quot;&quot;Fizzes and buzzes a given number into a string.&quot;&quot;&quot;
    if i % 3 == 0 and i % 5 == 0:
        return 'FizzBuzz'
    elif i % 3 == 0:
        return 'Fizz'
    elif i % 5 == 0:
        return 'Buzz'
    else:
        return str(i)


if __name__ == '__main__':
    for i in range(100):
        print(fizzbuzz(i))
</code></pre><p>This is functional, but I'm not quite feeling it yet.  Our range is a limited
generator, but functional languages are all cool and hip with their infinite
and lazily evaluated collections.  That's what we have generators for in
Python.  The <code>count</code> generator will keep supplying us with ascending integers
until the number can no longer fit into memory.  We will use <code>islice</code> to pick a
finite  subset.</p><pre><code>from itertools import count, islice


if __name__ == '__main__':
    for i in islice(count(1), 100):
        print(fizzbuzz(i))
</code></pre><p>Now we are getting somewhere.  Still though, it doesn't feel that functional
unless we have at least one <code>map</code>.</p><pre><code>if __name__ == '__main__':
    for line in islice(map(fizzbuzz, count(1)), 100):
        print(line)
</code></pre><p>Beautiful!  Now our code can only be understood by reading it inside-out.  I
wish we had a <code>foreach</code> function for side effects, but this will have to do.
Now there is just one thing left.  Functional languages pride themselves on
pattern-matching, and our <code>if</code>-<code>elif</code>-<code>else</code> chain looks so imperative.  Let's
fix it up before all the cool kids make fun of us.</p><pre><code>def fizzbuzz(i: int) -&gt; str:
    &quot;&quot;&quot;Fizzes and buzzes a given number.&quot;&quot;&quot;
    match (i % 3, i % 5):
        case (0, 0):
            return 'FizzBuzz'
        case (0, _):
            return 'Fizz'
        case (_, 0):
            return 'Buzz'
        case _:
            return str(i)
</code></pre><h3 id="Putting it all together">Putting it all together</h3><p>Here it is, a purely functional FizzBuzz in Python.</p><pre><code>from itertools import count, islice


def fizzbuzz(i: int) -&gt; str:
    &quot;&quot;&quot;Fizzes and buzzes a given number.&quot;&quot;&quot;
    match (i % 3, i % 5):
        case (0, 0):
            return 'FizzBuzz'
        case (0, _):
            return 'Fizz'
        case (_, 0):
            return 'Buzz'
        case _:
            return str(i)


if __name__ == '__main__':
    for line in islice(map(fizzbuzz, count(1)), 100):
        print(line)
</code></pre><h2 id="Property-testing it">Property-testing it</h2><p>Oops, we got carried away and forgot to write our tests first.  Let's travel
back in time (something, something, delimited continuations) and fix this.
Functional languages are cool and hip with their <a href="https://en.wikipedia.org/wiki/Property_testing">property testing</a> thanks to
the purity of their functions, so of course we are going to property test as
well.  We will use the <a href="https://hypothesis.readthedocs.io/en/latest/">Hypothesis</a> library for our tests.</p><p>Hypothesis will generate a bunch of random numbers and throw them one at a time
at our tests.  If we did everything right each and every single one will pass,
no matter how much we throw at it.  Because our <code>fizzbuzz</code> function is pure we
will never run into any side effects.</p><p>Here is what a property tests looks like:</p><pre><code>from .fizzbuzz import fizzbuzz
from hypothesis import given
from hypothesis.strategies import integers


@given(integers())
def test_unfizzbuzzable(i):
    &quot;&quot;&quot;Numbers which are divisible by neither 3 nor 5 are printed as is&quot;&quot;&quot;
    assert fizzbuzz(i) == str(i)
</code></pre><p>Of course this will fail because we are throwing any integers at it, not just
those indivisible by 3 and 5.  We need to filter the strategy returned by
<code>integers</code>.</p><pre><code>def fizzable(i: int) -&gt; bool:
    return i % 3 == 0


def buzzable(i: int) -&gt; bool:
    return i % 5 == 0


def unfizzable(i: int) -&gt; bool:
    return not fizzable(i)


def unbuzzable(i: int) -&gt; bool:
    return not buzzable(i)


@given(integers().filter(unfizzable).filter(unbuzzable))
def test_unfizzbuzzable(i):
    &quot;&quot;&quot;Numbers which are divisible by neither 3 nor 5 are printed as is&quot;&quot;&quot;
    assert fizzbuzz(i) == str(i)
</code></pre><p>Here we say that we only want integers which are both <code>unfizzable</code> and
<code>unbuzzable</code>.  With these functions and their positive counterparts we can also
define all the other test cases.</p><pre><code>@given(integers().filter(fizzable).filter(unbuzzable))
def test_fizzable(i):
    &quot;&quot;&quot;Numbers which are divisible by 3 but not by 5 are fizzed&quot;&quot;&quot;
    assert fizzbuzz(i) == 'Fizz'


@given(integers().filter(buzzable).filter(unfizzable))
def test_buzzable(i):
    &quot;&quot;&quot;Numbers which are divisible by 5 but not by 3 are buzzed&quot;&quot;&quot;
    assert fizzbuzz(i) == 'Buzz'


@given(integers().filter(fizzable).filter(buzzable))
def test_fizzbuzzable(i):
    &quot;&quot;&quot;Numbers which are divisible by both 3 and 5 are fizzbuzzed&quot;&quot;&quot;
    assert fizzbuzz(i) == 'FizzBuzz'
</code></pre><p>And that's it for testing, each test is only one line and we did not even need
to come up with test cases.</p><h2 id="Needs more lambdas and higher-order functions!">Needs more lambdas and higher-order functions!</h2><p>OK, with the tests out of the way it's time to go full-on functional, no more
holding back.  So far we have hard-coded the divisibility by 3 and 5, but what
if our client changes his mind because it's Thursday?  Our code is not flexible
enough, it needs to be declarative and data-driven!</p><p>Here is the plan: we provide a rule set in the form of a sequence of <code>(int, str)</code> tuples, then apply the rules to a higher-order function to produce the
actual fizz-buzzing function.  This way we can have any number of rules and
fizz-buzzing functions in our application and configure them at runtime.</p><p>First we need a <code>Rule</code> data structure.  We will use a typed named tuple for
that sweet extra type safety.</p><pre><code>from typing import NamedTuple


class Rule(NamedTuple):
    &quot;&quot;&quot;A single rule of the FizzBuzz game.&quot;&quot;&quot;
    number: int
    value: str

    def __str__(self) -&gt; str:
        return self.value
</code></pre><p>And this is how we use rules to do FizzBuzz:</p><pre><code>if __name__ == '__main__':
    rules = [Rule(3, 'Fizz'), Rule(5, 'Buzz')]
    fizzbuzz = compile_rules(rules)
    for line in islice(map(fizzbuzz, count(1)), 100):
        print(line)
</code></pre><p>The loop is the same, but the <code>fizzbuzz</code> function is constructed at runtime
from the list of rules.  The rules are compiled by the <code>compile_rules</code>
function.  I intentionally call it compilation because that is what is
happening: we are taking data and creating a real Python function.  If our
Python implementation was producing native machine code we would have an actual
native machine code generator.  But even as it is, this is still quite powerful.</p><h2 id="Testing again">Testing again</h2><p>Of course I adjusted the tests first before I wrote the above code.  I an just
putting tests here for didactic reasons.  Yeah, that's my story and I'm
sticking with it.</p><p>Previously I was generating the numbers to fizz-buzz, but in order to test our
compiler function we need to generate rules as well.</p><h2 id="Conclusion">Conclusion</h2></article><nav class="blog-pager"><a href="/blog/2024/02/29/introducing-neotest-busted/" rel="previous" style="float: left"><span aria-hidden="true">←</span> Introducing neotest-busted</a><a href="/blog/2024/08/15/testing-fennel-with-busted-in-lua/" rel="next" style="float: right">Testing Fennel in busted with Lua <span aria-hidden="true">→</span></a></nav></main><nav class="blog-navigation" aria-label="Blog navigation"><aside><span>subscribe:</span> <a href="/blog/rss.xml" type="application/rss+xml">RSS</a></aside><nav><h1><a href="/blog/archive/">archive</a></h1><ul><li><a href="/blog/2024/">2024 (7)</a></li><li><a href="/blog/2023/">2023 (11)</a></li><li><a href="/blog/2022/">2022 (13)</a></li><li><a href="/blog/2021/">2021 (5)</a></li><li><a href="/blog/2020/">2020 (15)</a></li><li><a href="/blog/2019/">2019 (17)</a></li><li><a href="/blog/2018/">2018 (1)</a></li><li><a href="/blog/2017/">2017 (4)</a></li><li><a href="/blog/2016/">2016 (6)</a></li><li><a href="/blog/2015/">2015 (2)</a></li></ul></nav><nav><h1><a href="/blog/categories/">categories</a></h1><ul><li><a href="/blog/categories/misc/">misc (21)</a></li><li><a href="/blog/categories/open-source/">open-source (24)</a></li><li><a href="/blog/categories/organisation/">organisation (14)</a></li><li><a href="/blog/categories/vim/">vim (22)</a></li></ul></nav><nav><h1><a href="/blog/tags/">tags</a></h1><ul><li><a href="/blog/tags/lisp/">lisp (21)</a></li><li><a href="/blog/tags/vim/">vim (20)</a></li><li><a href="/blog/tags/rant/">rant (14)</a></li><li><a href="/blog/tags/html/">html (10)</a></li><li><a href="/blog/tags/unix/">unix (8)</a></li><li><a href="/blog/tags/lua/">lua (7)</a></li><li><a href="/blog/tags/linux/">linux (5)</a></li><li><a href="/blog/tags/web/">web (4)</a></li><li><a href="/blog/tags/msgpack/">msgpack (3)</a></li><li><a href="/blog/tags/neovim/">neovim (3)</a></li><li><a href="/blog/tags/games/">games (3)</a></li><li><a href="/blog/tags/guix/">guix (2)</a></li><li><a href="/blog/tags/network/">network (2)</a></li><li><a href="/blog/tags/markdown/">markdown (2)</a></li><li><a href="/blog/tags/python/">python (2)</a></li><li><a href="/blog/tags/testing/">testing (2)</a></li><li><a href="/blog/tags/cocoa/">cocoa (1)</a></li><li><a href="/blog/tags/info/">info (1)</a></li><li><a href="/blog/tags/awk/">awk (1)</a></li><li><a href="/blog/tags/elixir/">elixir (1)</a></li><li><a href="/blog/tags/wine/">wine (1)</a></li><li><a href="/blog/tags/git/">git (1)</a></li><li><a href="/blog/tags/terminal/">terminal (1)</a></li><li><a href="/blog/tags/unity3d/">unity3d (1)</a></li><li><a href="/blog/tags/functional programming/">functional programming (1)</a></li></ul></nav></nav></div></div><footer><div><div class="footer-self"><a href="/" title="HiPhish's Workshop"><img src="/img/footer/logo.png" title="HiPhish's Workshop" height="55"/></a><p><a href="http://creativecommons.org/licenses/by-sa/4.0/"><img class="copyright-image" src="/img/footer/cc.svg" alt="Creative Commons Attribution-ShareAlike 4.0 International License"/> </a>© 2015-2022, licensed under <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a></p></div><div class="footer-social"><a href="https://github.com/HiPhish" title="GitHub" target="blank"><img src="/img/footer/github.png" alt="GitHub" height="55"/> </a><a href="https://gitlab.com/HiPhish" title="GitLab" target="blank"><img src="/img/footer/gitlab.png" alt="GitLab" height="55"/> </a></div></div></footer></body></html>